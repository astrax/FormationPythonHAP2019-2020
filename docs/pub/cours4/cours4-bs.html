<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Intégration numérique">

<title>Intégration numérique</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:60px;      /* fixed header height for style bootswatch_journal */
  margin:-60px 0 0; /* negative fixed header height */
}

body { font-size:20px;line-height:1.5; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table des matières',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Introduction', 1, None, '___sec0'),
              ("Idées de base de l'intégration numérique", 1, None, '___sec1'),
              ('Exemple de calcul', 2, None, '___sec2'),
              ('La règle du trapèze composite', 1, None, '___sec3'),
              ('La formule générale', 2, None, '___sec4'),
              ('Implémentation', 2, None, '___sec5'),
              ('Implémentation spécifique ou générale?', 3, None, '___sec6'),
              ('Implémentation avec fonctions', 3, None, '___sec7'),
              ('Résoudre notre problème spécifique en une session',
               3,
               None,
               '___sec8'),
              ('Résoudre notre problème spécifique dans un programme',
               3,
               None,
               '___sec9'),
              ('Faire un module', 3, None, '___sec10'),
              ('La méthode du point milieu composite', 1, None, '___sec11'),
              ("L'idée", 2, None, '___sec12'),
              ('La formule générale', 2, None, '___sec13'),
              ('Implémentation', 2, 'sec:implementation', 'sec:implementation'),
              ('Comparaison des méthodes du trapèze et du point milieu',
               2,
               None,
               '___sec15'),
              ('Intégration Monte Carlo', 1, None, '___sec16'),
              ('Exemple: détermination de $\\pi$', 2, None, '___sec17'),
              ('implémentation', 2, None, '___sec18')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="cours4-bs.html">Intégration numérique</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contenu <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#table_of_contents" style="font-size: 80%;"><b>Table des matières</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;"><b>Introduction</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;"><b>Idées de base de l'intégration numérique</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exemple de calcul</a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;"><b>La règle du trapèze composite</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;La formule générale</a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implémentation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implémentation spécifique ou générale?</a></li>
     <!-- navigation toc: --> <li><a href="#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implémentation avec fonctions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Résoudre notre problème spécifique en une session</a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Résoudre notre problème spécifique dans un programme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Faire un module</a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;"><b>La méthode du point milieu composite</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;L'idée</a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;La formule générale</a></li>
     <!-- navigation toc: --> <li><a href="#sec:implementation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implémentation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Comparaison des méthodes du trapèze et du point milieu</a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;"><b>Intégration Monte Carlo</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exemple: détermination de \( \pi \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;implémentation</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Int&#233;gration num&#233;rique</h1></center>  <!-- document title -->

<p>
<!-- author(s): Ahmed Ammar -->

<center>
<b>Ahmed Ammar</b>  (<tt>ahmed.ammar at fst.utm.tn</tt>)
</center>

<p>
<!-- institution -->

<center><b>Institut Pr&#233;paratoire aux &#201;tudes Scientifiques et Techniques, Universit&#233; de Carthage.</b></center>
<br>
<p>
<center><h4>Jan 20, 2020</h4></center> <!-- date -->
<br>
<p>
</div> <!-- end jumbotron -->

<h1 id="table_of_contents">Table des matières</h2>

<p>
<a href="#___sec0"> Introduction </a><br>
<a href="#___sec1"> Id&#233;es de base de l'int&#233;gration num&#233;rique </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Exemple de calcul </a><br>
<a href="#___sec3"> La r&#232;gle du trap&#232;ze composite </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> La formule g&#233;n&#233;rale </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> Impl&#233;mentation </a><br>
<a href="#___sec11"> La m&#233;thode du point milieu composite </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> L'id&#233;e </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> La formule g&#233;n&#233;rale </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:implementation"> Impl&#233;mentation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> Comparaison des m&#233;thodes du trap&#232;ze et du point milieu </a><br>
<a href="#___sec16"> Int&#233;gration Monte Carlo </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Exemple: d&#233;termination de \( \pi \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> impl&#233;mentation </a><br>
</p>
<p>
<!-- !split -->

<h1 id="___sec0" class="anchor">Introduction </h1>
L'int&#233;gration num&#233;rique est un chapitre important de l'analyse num&#233;rique et un outil indispensable en physique num&#233;rique. On int&#232;gre num&#233;riquement dans deux cas principaux:

<ul>
<li> on ne peut pas int&#233;grer analytiquement,</li>
<li> l'int&#233;grande est fourni non pas sous la forme d'une fonction mais de tableaux de mesures, cas d'ailleurs le plus fr&#233;quent dans la vraie vie.</li>
</ul>

Les m&#233;thodes num&#233;riques d'int&#233;gration d'une fonction sont nombreuses et les techniques tr&#232;s diverses. Des tr&#232;s simples, comme la m&#233;thode des rectangles aux tr&#232;s complexes comme certaines vari&#233;t&#233;s de la m&#233;thode de Monte-Carlo.

<p>
<!-- !split -->

<h1 id="___sec1" class="anchor">Id&#233;es de base de l'int&#233;gration num&#233;rique </h1>
Nous consid&#233;rons l'int&#233;grale
$$
\begin{equation} \label{eq:ExempleIntegral}
\int_a^b f(x)dx
\end{equation}
$$

La plupart des m&#233;thodes num&#233;riques de calcul de cette int&#233;grale divisent l'int&#233;grale d'origine en une somme de plusieurs int&#233;grales, chacune couvrant une partie plus petite de l'intervalle d'int&#233;gration d'origine \( [a, b] \). Cette r&#233;&#233;criture de l'int&#233;grale est bas&#233;e sur une s&#233;lection de points d'int&#233;gration \( x_i \), \( i = 0,1,&#8230;, n \) qui sont r&#233;partis sur l'intervalle \( [a, b] \). Les points d'int&#233;gration peuvent ou non &#234;tre r&#233;partis uniform&#233;ment. Une distribution uniforme simplifie les expressions et est souvent suffisante, nous nous limiterons donc principalement &#224; ce choix. Les points d'int&#233;gration sont ensuite calcul&#233;s comme:
$$
\begin{equation}
x_i = a + ih,\quad i = 0,1,\ldots,n
\label{_auto1}
\end{equation}
$$

o&#249;
$$
\begin{equation}
h = \frac{b-a}{n}
\label{_auto2}
\end{equation}
$$

Compte tenu des points d'int&#233;gration, l'int&#233;grale d'origine est r&#233;&#233;crite sous la forme d'une somme d'int&#233;grales, chaque int&#233;grale &#233;tant calcul&#233;e sur le sous-intervalle entre deux points d'int&#233;gration cons&#233;cutifs. L'int&#233;grale dans \eqref{eq:ExempleIntegral} est donc exprim&#233;e comme:
$$
\begin{equation} \label{eq:SumIntegrals}
\int_a^b f(x)dx =
\int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx + \ldots +
\int_{x_{n-1}}^{x_n} f(x)dx
\end{equation}
$$

Notez que \( x_0 = a \) et \( x_n = b \).

<p>
En partant de \eqref{eq:SumIntegrals}, les diff&#233;rentes m&#233;thodes d'int&#233;gration diff&#233;reront dans la fa&#231;on dont elles approchent chaque int&#233;grale du c&#244;t&#233; droit. L'id&#233;e fondamentale est que chaque terme est une int&#233;grale sur un petit intervalle \( [x_i, x_{i + 1}] \), et sur ce petit intervalle, il est logique d'approximer f par une forme simple, disons une constante, une ligne droite ou une parabole , que nous pouvons facilement int&#233;grer &#224; la main. Les d&#233;tails deviendront clairs dans les exemples &#224; venir.

<h2 id="___sec2" class="anchor">Exemple de calcul </h2>
Pour comprendre et comparer les m&#233;thodes d'int&#233;gration num&#233;rique, il est avantageux d'utiliser une int&#233;grale sp&#233;cifique pour les calculs et les illustrations graphiques. En particulier, nous voulons utiliser une int&#233;grale que nous pouvons calculer &#224; la main de sorte que la pr&#233;cision des m&#233;thodes d'approximation puisse &#234;tre facilement &#233;valu&#233;e. Notre int&#233;grale sp&#233;cifique est tir&#233;e de la physique de base. Supposons que vous acc&#233;l&#233;rez votre voiture du repos et demandez-vous jusqu'o&#249; vous allez en \( T \) secondes. La distance est donn&#233;e par l'int&#233;grale \( \int_0^T v(t)dt \) , o&#249; \( v (t) \) est la vitesse en fonction du temps. Une fonction de vitesse en augmentation rapide pourrait &#234;tre:
$$
\begin{equation}
v\left(t\right) = 3t^{2}e^{t^3}\thinspace
\label{_auto3}
\end{equation}
$$

La distance apr&#232;s une seconde est
$$
\begin{equation} \label{eq:SpeedIntegral}
\int_0^1 v(t)dt
\end{equation}
$$

qui est l'int&#233;grale que nous cherchons &#224; calculer par des m&#233;thodes num&#233;riques. Heureusement, l'expression choisie de la vitesse a une forme qui permet de calculer facilement la primitive comme
$$
\begin{equation}
V(t) = e^{t^3}-1
\label{_auto4}
\end{equation}
$$

Nous pouvons donc calculer la valeur exacte de l'int&#233;grale comme \( V (1) &#8722;V (0) &#8776;1.718 \) (arrondi &#224; 3 d&#233;cimales pour plus de commodit&#233;).

<h1 id="___sec3" class="anchor">La r&#232;gle du trap&#232;ze composite </h1>
L'int&#233;grale \( \int_a^b f(x)dx \) peut &#234;tre interpr&#233;t&#233; comme l'aire entre l'axe des x et le graphique \( y = f (x) \) de fonction &#224; int&#233;grer. La figure <a href="#fig:integral_of_f">1</a> illustre cette zone de choix \eqref{eq:SpeedIntegral}. Le calcul de l'int&#233;grale \( \int_0^1f(t)dt \) revient &#224; calculer l'aire de la zone hachur&#233;e.

<p>
<center> <!-- figure label: --> <div id="fig:integral_of_f"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  L'int&#233;grale de \( v (t) \) interpr&#233;t&#233;e comme l'aire sous le graphique de \( v \).  <!-- caption label: fig:integral_of_f --> </p></center>
<p><img src="imgs/integral_of_f.png" align="bottom" width=400></p>
</center>

<p>
Si nous rempla&#231;ons le vrai graphique de la figure <a href="#fig:integral_of_f">1</a> par un ensemble de segments de ligne droite, nous pouvons voir la zone plut&#244;t comme compos&#233;e de trap&#232;zes, dont les zones sont faciles &#224; calculer. Ceci est illustr&#233; sur la figure <a href="#fig:viz_trapezoidal">2</a>, o&#249; 4 segments de ligne droite donnent naissance &#224; 4 trap&#232;zes, couvrant les intervalles de temps \( [0,0.2) \), \( [0.2,0.6) \), \( [0.6,0.8) \) et \( [0.8,1.0] \). Notez que nous en avons profit&#233; pour d&#233;montrer les calculs avec des intervalles de temps de tailles diff&#233;rentes.

<p>
<center> <!-- figure label: --> <div id="fig:viz_trapezoidal"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Calculer approximativement l'int&#233;grale d'une fonction comme la somme des aires des trap&#232;zes.  <!-- caption label: fig:viz_trapezoidal --> </p></center>
<p><img src="imgs/viz_trapezoidal.png" align="bottom" width=400></p>
</center>

<p>
Les aires des 4 trap&#232;zes repr&#233;sent&#233;s sur la figure <a href="#fig:viz_trapezoidal">2</a> constituent maintenant notre approximation de l'int&#233;grale \eqref{eq:SpeedIntegral}:
$$
\begin{align}
\int_0^1 v(t)dt &\approx
h_1 (\frac{v(0)+v(0.2)}{2}) + h_2 (\frac{v(0.2)+v(0.6)}{2}) \nonumber  \\
&+ h_3 (\frac{v(0.6)+v(0.8)}{2}) + h_4 (\frac{v(0.8)+v(1.0)}{2})
\label{eq:trapezoids}
\end{align}
$$

o&#249;
$$
\begin{align}
h_1 &= (0.2 - 0.0) \label{eq:h1}\\
h_2 &= (0.6 - 0.2)  \label{eq:h2}\\
h_3 &= (0.8 - 0.6)  \label{eq:h3}\\
h_4 &= (1.0 - 0.8) \label{eq:h4}
\end{align}
$$

Avec \( v(t) = 3t^{2}e^{t^3} \), chaque terme dans \eqref{eq:trapezoids} est facilement calcul&#233; et notre calcul approximatif donne
$$
\begin{equation}
\int_0^1 v(t)dt \approx 1.895
\label{_auto5}
\end{equation}
$$

Par rapport &#224; la vraie r&#233;ponse de \( 1.718 \), cela est d'environ \( 10 \% \). Cependant, notez que nous avons utilis&#233; seulement 4 trap&#232;zes pour approximer la zone. Avec plus de trap&#232;zes, l'approximation serait devenue meilleure, puisque les segments de droite du c&#244;t&#233; sup&#233;rieur des trap&#232;zes suivraient alors le graphique de plus pr&#232;s. Faire un autre calcul avec plus de trap&#232;zes n'est pas trop tentant pour un humain paresseux, mais c'est un travail parfait pour un ordinateur! D&#233;rivons donc les expressions d'approximation de l'int&#233;grale par un nombre arbitraire de trap&#232;zes.

<h2 id="___sec4" class="anchor">La formule g&#233;n&#233;rale </h2>
Pour une fonction donn&#233;e \( f (x) \), nous voulons approximer l'int&#233;grale \( \int_a^bf(x)dx \) par \( n \) trap&#232;zes (de largeur &#233;gale). Nous commen&#231;ons par \eqref{eq:SumIntegrals} et approchons chaque int&#233;grale du c&#244;t&#233; droit avec un seul trap&#232;ze. En d&#233;tail,
$$
\begin{align}
\int_a^b f(x)\,dx &= \int_{x_0}^{x_1} f(x) dx + \int_{x_1}^{x_2} f(x) dx + \ldots + \int_{x_{n-1}}^{x_n} f(x) dx,     \nonumber \\
                  &\approx h \frac{f(x_0) + f(x_1)}{2} +
		  h \frac{f(x_1) + f(x_2)}{2} + \ldots + \nonumber \\
		  &\quad h \frac{f(x_{n-1}) + f(x_n)}{2} \label{eq:SumTrapezes}
\end{align}
$$

En simplifiant le c&#244;t&#233; droit de \eqref{eq:SumTrapezes}, nous obtenons
$$
\begin{equation}
\int_a^b f(x)\,dx \approx \\
\frac{h}{2}\left[f(x_0) + 2 f(x_1) + 2 f(x_2) + \ldots + 2 f(x_{n-1}) + f(x_n)\right]
\label{_auto6}
\end{equation}
$$

qui est &#233;crit de fa&#231;on plus compacte comme
$$
\begin{equation} \label{eq:GenralIntegral}
\int_a^b f(x)\,dx \approx h \left[\frac{1}{2}f(x_0) + \sum_{i=1}^{n-1}f(x_i) + \frac{1}{2}f(x_n) \right]
\end{equation}
$$

<div class="panel panel-primary">
  <div class="panel-heading">
  <h3 class="panel-title">R&#232;gles d'int&#233;gration composites</h3>
  </div>
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Le mot composite est souvent utilis&#233; lorsqu'une m&#233;thode d'int&#233;gration num&#233;rique est appliqu&#233;e avec plus d'un sous-intervalle.
&#224; vrai dire alors, &#233;crire, par exemple, "la m&#233;thode du trap&#232;ze", devrait impliquer l'utilisation d'un seul trap&#232;ze, tandis que "la m&#233;thode du trap&#232;ze composite" est le nom le plus correct lorsque plusieurs trap&#232;zes sont utilis&#233;s. Cependant, cette convention de d&#233;nomination n'est pas toujours suivie, donc dire que "la m&#233;thode du trap&#232;ze" peut pointer vers un seul trap&#232;ze ainsi que la r&#232;gle composite avec de nombreux trap&#232;zes.
</div>
</div>


<h2 id="___sec5" class="anchor">Impl&#233;mentation </h2>

<h3 id="___sec6" class="anchor">Impl&#233;mentation sp&#233;cifique ou g&#233;n&#233;rale? </h3>

Supposons que notre objectif principal &#233;tait de calculer l'int&#233;grale sp&#233;cifique \( \int_0^1 v(t)dt \) avec \( v(t)=3t^2e^{t^3} \). D'abord, nous avons jou&#233; avec un simple calcul de main pour voir de quoi il s'agissait, avant de d&#233;velopper (comme c'est souvent le cas en math&#233;matiques) une formule g&#233;n&#233;rale \eqref{eq:GenralIntegral} pour l'int&#233;grale g&#233;n&#233;rale ou &#171;abstraite&#187; \( \int_a^bf(x)dx \). Pour r&#233;soudre notre probl&#232;me sp&#233;cifique \( \int_0^1 v(t)dt \), nous devons ensuite appliquer la formule g&#233;n&#233;rale \eqref{eq:GenralIntegral} aux donn&#233;es donn&#233;es (fonction et limites int&#233;grales) dans notre probl&#232;me. Bien que simples en principe, les &#233;tapes pratiques sont d&#233;routantes pour beaucoup car la notation dans le probl&#232;me abstrait de \eqref{eq:GenralIntegral} diff&#232;re de la notation dans notre probl&#232;me sp&#233;cial. Clairement, les \( f \), \( x \) et \( h \) dans \eqref{eq:GenralIntegral} correspondent &#224; \( v \), \( t \) et peut-&#234;tre \( \Delta t \) pour la largeur du trap&#232;ze dans notre probl&#232;me sp&#233;cial.
<div class="panel panel-success">
  <div class="panel-heading">
  <h3 class="panel-title">Le dilemme du programmeur</h3>
  </div>
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->

<ol>
<li> Faut-il &#233;crire un programme sp&#233;cial pour l'int&#233;grale sp&#233;ciale, en utilisant les id&#233;es de la r&#232;gle g&#233;n&#233;rale \eqref{eq:GenralIntegral}, mais en rempla&#231;ant \( f \) par \( v \), \( x \) par \( t \) et \( h \) par \( \Delta t \)?</li>
<li> Faut-il impl&#233;menter la m&#233;thode g&#233;n&#233;rale \eqref{eq:GenralIntegral} telle qu'elle se pr&#233;sente dans une fonction g&#233;n&#233;rale <code>trapeze(f, a, b, n)</code> et r&#233;soudre le probl&#232;me sp&#233;cifique en question par un appel sp&#233;cialis&#233; &#224; cette fonction?</li>
</ol>

<b>L'alternative 2 est toujours le meilleur choix!</b>
</div>
</div>


<p>
La premi&#232;re alternative dans l'encadr&#233; ci-dessus semble moins abstraite et donc plus attrayante pour beaucoup. N&#233;anmoins, comme nous l'esp&#233;rons, cela sera &#233;vident &#224; partir des exemples, la deuxi&#232;me alternative est en fait la plus simple et la plus fiable d'un point de vue math&#233;matique et de programmation. Ces auteurs affirmeront que la deuxi&#232;me alternative est l'essence m&#234;me du pouvoir des math&#233;matiques, tandis que la premi&#232;re alternative est la source de beaucoup de confusion sur les math&#233;matiques!

<h3 id="___sec7" class="anchor">Impl&#233;mentation avec fonctions </h3>

Pour l'int&#233;grale \( \int_a^bf(x)dx \) calcul&#233;e par la formule \eqref{eq:GenralIntegral}, nous voulons que le trap&#232;ze de la fonction Python correspondante prenne tout \( f \), \( a \), \( b \) et \( n \) en entr&#233;e et renvoie l'approximation &#224; l'int&#233;grale.

<p>
Nous &#233;crivons une fonction Python <code>trapeze()</code> dans un fichier <code>trapeze_integral.py</code> aussi proche que possible de la formule \eqref{eq:GenralIntegral}, en nous assurant que les noms de variables correspondent &#224; la notation math&#233;matique:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">## NOM DU PROGRAMME: trapeze_integral.py</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">trapeze</span>(f, a, b, n):
    h <span style="color: #666666">=</span> (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    result <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>f(a) <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>f(b)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, n):
        xi <span style="color: #666666">=</span> a <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h
        result <span style="color: #666666">+=</span> f(xi)
    result <span style="color: #666666">*=</span> h
    <span style="color: #008000; font-weight: bold">return</span> result
</pre></div>

<h3 id="___sec8" class="anchor">R&#233;soudre notre probl&#232;me sp&#233;cifique en une session </h3>

Le simple fait d'avoir la fonction <code>trapeze()</code> comme seul contenu d'un fichier <code>trapeze_integral.py</code> fait automatiquement de ce fichier un module que nous pouvons importer et tester dans une session interactive:
<p>

<!-- code=python (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>In [<span style="color: #666666">3</span>]: <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">trapeze_integral</span> <span style="color: #008000; font-weight: bold">import</span> trapeze
In [<span style="color: #666666">4</span>]: <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp
In [<span style="color: #666666">5</span>]: v <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">3*</span>(t<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>exp(t<span style="color: #666666">**3</span>)
In [<span style="color: #666666">6</span>]: n <span style="color: #666666">=</span> <span style="color: #666666">4</span>
In [<span style="color: #666666">7</span>]: numerical <span style="color: #666666">=</span> trapeze(v, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n)
In [<span style="color: #666666">8</span>]: numerical
Out[<span style="color: #666666">8</span>]: <span style="color: #666666">1.9227167504675762</span>
</pre></div>
<p>
Calculons l'expression exacte et l'erreur dans l'approximation:
<p>

<!-- code=python (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>In [<span style="color: #666666">9</span>]: V <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: exp(t<span style="color: #666666">**3</span>) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
In [<span style="color: #666666">10</span>]: exact <span style="color: #666666">=</span> V(<span style="color: #666666">1</span>) <span style="color: #666666">-</span> V(<span style="color: #666666">0</span>)
In [<span style="color: #666666">11</span>]: exact <span style="color: #666666">-</span> numerical
Out[<span style="color: #666666">11</span>]: <span style="color: #666666">-0.20443492200853108</span>
</pre></div>
<p>
Cette erreur est-elle convaincante? On peut essayer un \( n \) plus grand:
<p>

<!-- code=python (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>In [<span style="color: #666666">12</span>]: numerical <span style="color: #666666">=</span> trapeze(v, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n<span style="color: #666666">=400</span>)
In [<span style="color: #666666">13</span>]: exact <span style="color: #666666">-</span> numerical
Out[<span style="color: #666666">13</span>]: <span style="color: #666666">-2.1236490512777095e-05</span>
</pre></div>
<p>
Heureusement, beaucoup plus de trap&#232;zes donnent une erreur beaucoup plus petite.

<h3 id="___sec9" class="anchor">R&#233;soudre notre probl&#232;me sp&#233;cifique dans un programme </h3>

Au lieu de calculer notre probl&#232;me sp&#233;cial dans une session interactive, nous pouvons le faire dans un programme. Comme toujours, un morceau de code faisant une chose particuli&#232;re est mieux isol&#233; en tant que fonction m&#234;me si nous ne voyons aucune raison future d'appeler la fonction plusieurs fois et m&#234;me si nous n'avons pas besoin d'arguments pour param&#233;trer ce qui se passe &#224; l'int&#233;rieur de la fonction. Dans le cas pr&#233;sent, nous mettons simplement les instructions que nous aurions autrement mises dans un programme principal, &#224; l'int&#233;rieur d'une fonction:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">application</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp
    v <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">3*</span>(t<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>exp(t<span style="color: #666666">**3</span>)
    n <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">input</span>(<span style="color: #BA2121">&#39;n: &#39;</span>))
    numerical <span style="color: #666666">=</span> trapeze(v, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n)

    <span style="color: #408080; font-style: italic"># Comparer avec le résultat exact</span>
    V <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: exp(t<span style="color: #666666">**3</span>) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    exact <span style="color: #666666">=</span> V(<span style="color: #666666">1</span>) <span style="color: #666666">-</span> V(<span style="color: #666666">0</span>)
    <span style="color: #008000; font-weight: bold">print</span>(exact)
    error <span style="color: #666666">=</span> exact <span style="color: #666666">-</span> numerical
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;n=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121">, erreur: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (n, numerical, error))
</pre></div>
<p>
Maintenant, nous calculons notre probl&#232;me sp&#233;cial en appelant <code>application()</code> comme la seule instruction du programme principal.

<h3 id="___sec10" class="anchor">Faire un module </h3>

Lorsque nous avons les diff&#233;rentes parties de notre programme comme une collection de fonctions, il est tr&#232;s simple de cr&#233;er un <em>module</em> qui peut &#234;tre import&#233; dans d'autres programmes. Ce fait, avoir notre code comme module, signifie que la fonction <code>trapeze()</code> peut facilement &#234;tre r&#233;utilis&#233;e par d'autres programmes pour r&#233;soudre d'autres probl&#232;mes. Les exigences d'un module sont simples: mettez tout &#224; l'int&#233;rieur des fonctions et laissez les appels de fonction dans le programme principal &#234;tre dans le soi-disant <em>bloc de test</em>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">if</span> <span style="color: #19177C">__name__</span> <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    application()
</pre></div>
<p>
Le test <code>if</code> est vrai si le fichier de module, <code>trapeze_integral.py</code>, est ex&#233;cut&#233; en tant que programme et faux si le module est import&#233; dans un autre programme. Par cons&#233;quent, lorsque nous effectuons une importation: <code>from trapeze_integral import trapeze</code> dans un fichier, le test &#233;choue et <code>application()</code> n'est pas appel&#233;e, c'est-&#224;-dire que notre probl&#232;me sp&#233;cial n'est pas r&#233;solu et n'imprime rien &#224; l'&#233;cran. D'un autre c&#244;t&#233;, si nous ex&#233;cutons <code>trapeze_integral.py</code> dans la fen&#234;tre du terminal, la condition de test est positive, <code>application()</code> est appel&#233;e et nous obtenons une sortie dans la fen&#234;tre:

<p>

<!-- code=text (!bc pycodext) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>Terminal&gt; python trapeze_integral.py
n: 400
n=400: 1.7183030649495579, error: -2.12365e-05
</pre></div>

<h1 id="___sec11" class="anchor">La m&#233;thode du point milieu composite </h1>

<h2 id="___sec12" class="anchor">L'id&#233;e </h2>
Plut&#244;t que d'approximer l'aire sous une courbe par des trap&#232;zes, nous pouvons utiliser des rectangles simples. Il peut sembler moins pr&#233;cis d'utiliser des lignes horizontales et non des lignes obliques suivant la fonction &#224; int&#233;grer, mais une m&#233;thode d'int&#233;gration bas&#233;e sur des rectangles (la m&#233;thode du point milieu) est en fait l&#233;g&#232;rement plus pr&#233;cise que celle bas&#233;e sur des trap&#232;zes!

<p>
Dans la m&#233;thode du milieu, nous construisons un rectangle pour chaque sous-intervalle o&#249; la hauteur est &#233;gale &#224; \( f \) au milieu du sous-intervalle. Faisons-le pour quatre rectangles, en utilisant les m&#234;mes sous-intervalles que nous avions pour les calculs manuels avec la m&#233;thode du trap&#232;ze: \( [0,0.2) \), \( [0.2,0.6) \), \( [0.6,0.8) \) et \( [0.8,1.0] \). On a
$$
\begin{align}
\int_0^1 f(t)dt &\approx
   h_1 f\left(\frac{0 + 0.2}{2}\right) +
   h_2 f\left(\frac{0.2 + 0.6}{2}\right) \nonumber  \\
&+ h_3 f\left(\frac{0.6 + 0.8}{2}\right) +
   h_4 f\left(\frac{0.8 + 1.0}{2}\right)
\label{_auto7}
\end{align}
$$

o&#249; \( h_1 \), \( h_2 \), \( h_3 \) et \( h_4 \) sont les largeurs des sous-intervalles, utilis&#233;es pr&#233;c&#233;demment avec la m&#233;thode du trap&#232;ze et d&#233;finies dans \eqref{eq:h1}-\eqref{eq:h4}.

<p>
<center> <!-- figure label: --> <div id="fig:viz_midpoint"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Calcul approximatif de l'int&#233;grale d'une fonction comme la somme des aires des rectangles.  <!-- caption label: fig:viz_midpoint --> </p></center>
<p><img src="imgs/viz_midpoint.png" align="bottom" width=400></p>
</center>

<p>
Avec \( f(t) = 3t^{2}e^{t^3} \), l'approximation devient \( 1.632 \). Compar&#233; &#224; la vraie r&#233;ponse (\( 1.718 \)), c'est environ \( 5 \% \) trop petit, mais c'est mieux que ce que nous avons obtenu avec la m&#233;thode trap&#233;zo&#239;dale (\( 10 \% \)) avec les m&#234;mes sous-intervalles. Plus de rectangles donnent une meilleure approximation.

<h2 id="___sec13" class="anchor">La formule g&#233;n&#233;rale </h2>
D&#233;rivons une formule pour la m&#233;thode du milieu bas&#233;e sur \( n \) rectangles d'&#233;gale largeur:
$$
\begin{align}
\int_a^b f(x)\,dx &= \int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx +
                     \ldots + \int_{x_{n-1}}^{x_n} f(x)dx,     \nonumber \\
                  &\approx h f\left(\frac{x_0 + x_1}{2}\right) +
                   h f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                   h f\left(\frac{x_{n-1} + x_n}{2}\right) 
\label{_auto8}\\
                  &\approx h \left(f\left(\frac{x_0 + x_1}{2}\right) +
                  f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                  f\left(\frac{x_{n-1} + x_n}{2}\right)\right)
\label{_auto9}
\end{align}
$$

Cette somme peut &#234;tre &#233;crite de fa&#231;on plus compacte comme
$$
\begin{equation} \label{eq:GeneralMidpoint}
\int_a^b f(x) dx \approx h \sum_{i=0}^{n-1}f(x_i)
\end{equation}
$$

o&#249; \( x_i = \left(a + \frac{h}{2}\right) + ih \).

<h2 id="sec:implementation" class="anchor">Impl&#233;mentation</h2>
Nous suivons les conseils et les enseignements tir&#233;s de l'impl&#233;mentation de la m&#233;thode trap&#232;ze et r&#233;alisons une fonction <code>midpoint(f, a, b, n)</code> (dans un fichier <code>midpoint_integral.py</code>) pour impl&#233;menter la formule g&#233;n&#233;rale \eqref{eq:GeneralMidpoint}:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">## NOM DU PROGRAMME: midpoint_integral.py</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint</span>(f, a, b, n):
    h <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    result <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        xi <span style="color: #666666">=</span> (a <span style="color: #666666">+</span> h<span style="color: #666666">/2.0</span>) <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h
        result <span style="color: #666666">+=</span> f(xi)
    result <span style="color: #666666">*=</span> h
    <span style="color: #008000; font-weight: bold">return</span> result
</pre></div>
<p>
Nous pouvons tester la fonction comme nous l'avons expliqu&#233; pour la m&#233;thode du trap&#232;ze similaire. L'erreur dans notre probl&#232;me particulier \( \int_0^1 3t^2e^{t^3}dt \) avec quatre intervalles est maintenant d'environ \( 0.1 \) contrairement &#224; \( 0.2 \) pour la r&#232;gle du trap&#232;ze. Les diff&#233;rences sont rarement d'une importance pratique, et sur un ordinateur portable, nous pouvons facilement utiliser \( n = 10^6 \) et obtenir la r&#233;ponse avec une erreur d'environ \( 10^{-12} \) en quelques secondes.

<h2 id="___sec15" class="anchor">Comparaison des m&#233;thodes du trap&#232;ze et du point milieu </h2>
L'exemple suivant montre la facilit&#233; avec laquelle nous pouvons combiner les fonctions <code>trapeze()</code> et <code>midpoint()</code> pour comparer les deux m&#233;thodes dans le fichier <code>compare_integration_methods.py</code>:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">## NOM DU PROGRAMME: compare_integration_methods.py</span>
<span style="color: #408080; font-style: italic">#% IMPORTATION</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">trapeze_integral</span> <span style="color: #008000; font-weight: bold">import</span> trapeze
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">midpoint_integral</span> <span style="color: #008000; font-weight: bold">import</span> midpoint
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp

g <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> y: exp(<span style="color: #666666">-</span>y<span style="color: #666666">**2</span>)
a <span style="color: #666666">=</span> <span style="color: #666666">0</span>
b <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;      n      point milieu     trapèze&quot;</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">21</span>):
    n <span style="color: #666666">=</span> <span style="color: #666666">2**</span>i
    m <span style="color: #666666">=</span> midpoint(g, a, b, n)
    t <span style="color: #666666">=</span> trapeze(g, a, b, n)
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%7d</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">%</span>(n, m, t))
</pre></div>
<p>
Notez les efforts mis en forme agr&#233;able - la sortie devient
<p>

<!-- code=shell (!bc shell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>      n      point milieu     trapèze
      <span style="color: #666666">2</span> <span style="color: #666666">0</span>.8842000076332692 <span style="color: #666666">0</span>.8770372606158094
      <span style="color: #666666">4</span> <span style="color: #666666">0</span>.8827889485397279 <span style="color: #666666">0</span>.8806186341245393
      <span style="color: #666666">8</span> <span style="color: #666666">0</span>.8822686991994210 <span style="color: #666666">0</span>.8817037913321336
     <span style="color: #666666">16</span> <span style="color: #666666">0</span>.8821288703366458 <span style="color: #666666">0</span>.8819862452657772
     <span style="color: #666666">32</span> <span style="color: #666666">0</span>.8820933014203766 <span style="color: #666666">0</span>.8820575578012112
     <span style="color: #666666">64</span> <span style="color: #666666">0</span>.8820843709743319 <span style="color: #666666">0</span>.8820754296107942
    <span style="color: #666666">128</span> <span style="color: #666666">0</span>.8820821359746071 <span style="color: #666666">0</span>.8820799002925637
    <span style="color: #666666">256</span> <span style="color: #666666">0</span>.8820815770754198 <span style="color: #666666">0</span>.8820810181335849
    <span style="color: #666666">512</span> <span style="color: #666666">0</span>.8820814373412922 <span style="color: #666666">0</span>.8820812976045025
   <span style="color: #666666">1024</span> <span style="color: #666666">0</span>.8820814024071774 <span style="color: #666666">0</span>.8820813674728968
   <span style="color: #666666">2048</span> <span style="color: #666666">0</span>.8820813936736116 <span style="color: #666666">0</span>.8820813849400392
   <span style="color: #666666">4096</span> <span style="color: #666666">0</span>.8820813914902204 <span style="color: #666666">0</span>.8820813893068272
   <span style="color: #666666">8192</span> <span style="color: #666666">0</span>.8820813909443684 <span style="color: #666666">0</span>.8820813903985197
  <span style="color: #666666">16384</span> <span style="color: #666666">0</span>.8820813908079066 <span style="color: #666666">0</span>.8820813906714446
  <span style="color: #666666">32768</span> <span style="color: #666666">0</span>.8820813907737911 <span style="color: #666666">0</span>.8820813907396778
 <span style="color: #666666">131072</span> <span style="color: #666666">0</span>.8820813907631487 <span style="color: #666666">0</span>.8820813907610036
 <span style="color: #666666">262144</span> <span style="color: #666666">0</span>.8820813907625702 <span style="color: #666666">0</span>.8820813907620528
 <span style="color: #666666">524288</span> <span style="color: #666666">0</span>.8820813907624605 <span style="color: #666666">0</span>.8820813907623183
<span style="color: #666666">1048576</span> <span style="color: #666666">0</span>.8820813907624268 <span style="color: #666666">0</span>.8820813907623890
</pre></div>
<p>
Une inspection visuelle des chiffres montre &#224; quelle vitesse les chiffres se stabilisent dans les deux m&#233;thodes. Il semble que 13 chiffres se soient stabilis&#233;s dans les deux derni&#232;res lignes.

<p>
<div class="panel panel-primary">
  <div class="panel-heading">
  <h3 class="panel-title">Remarque</h3>
  </div>
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Les m&#233;thodes du trap&#232;ze et du point milieu ne sont que deux exemples dans une jungle de r&#232;gles d'int&#233;gration num&#233;rique. D'autres m&#233;thodes c&#233;l&#232;bres sont la r&#232;gle de Simpson et la quadrature de Gauss. Ils fonctionnent tous de la m&#234;me mani&#232;re:
$$\int_a^b f(x)dx \approx \sum_{i=0}^{n-1} w_if(x_i)$$
Autrement dit, l'int&#233;grale est approxim&#233;e par une somme d'&#233;valuations de fonctions, o&#249; chaque &#233;valuation \( f (x_i) \) re&#231;oit un poids \( w_i \). Les diff&#233;rentes m&#233;thodes diff&#232;rent par la fa&#231;on dont elles construisent les points d'&#233;valuation \( x_i \) et les poids \( w_i \). Nous avons utilis&#233; des points \( x_i \) &#233;galement espac&#233;s, mais une pr&#233;cision plus &#233;lev&#233;e peut &#234;tre obtenue en optimisant l'emplacement de \( x_i \).
</div>
</div>


<p>
<!-- ======= Int&#233;grales doubles et triples ======= -->
<!-- ===== La r&#232;gle du point milieu pour une double int&#233;grale ===== -->
<!-- <div id="sec:midpointDouble"></div> -->
<!-- &#201;tant donn&#233; une int&#233;grale double sur un domaine rectangulaire \( [a, b] \times [c, d] \), -->
<!--  -->
<!-- $$\int_a^b \int_c^d f(x,y) dydx$$ -->
<!--  -->
<!-- comment approcher cette int&#233;grale par des m&#233;thodes num&#233;riques? -->
<!-- === D&#233;rivation via des int&#233;grales unidimensionnelles === -->
<!-- Puisque nous savons comment traiter les int&#233;grales &#224; une variable, une approche fructueuse consiste &#224; consid&#233;rer l'int&#233;grale double comme deux int&#233;grales, chacune &#224; une variable, qui peut &#234;tre approxim&#233;e num&#233;riquement par les formules unidimensionnelles pr&#233;c&#233;dentes. &#192; cette fin, nous introduisons une fonction interm&#233;diaire \( g (x) \) et &#233;crivons -->
<!-- $$\int_a^b \int_c^d f(x,y) dydx = \int_a^b g(x)dx,\quad -->
<!-- g(x) = \int_c^d f(x,y) dy$$ -->
<!-- Chacune des int&#233;grales -->
<!-- $$ \int_a^b g(x)dx,\quad -->
<!-- g(x) = \int_c^d f(x,y) dy$$ -->
<!-- peut &#234;tre discr&#233;tis&#233; par n'importe quelle r&#232;gle d'int&#233;gration num&#233;rique pour une int&#233;grale dans une variable. Utilisons la m&#233;thode du point milieu \eqref{eq:GeneralMidpoint} et commen&#231;ons par \( g(x)=\int_c^d f(x,y)dy \). Nous introduisons \( n_y \) intervalles sur \( [c, d] \) de longueur \( h_y \). La r&#232;gle du point milieu pour cette int&#233;grale devient alors -->
<!-- $$g(x) = \int_c^d f(x,y) dy \approx  h_y \sum_{j=0}^{n_y-1} f(x,y_j), -->
<!-- \quad y_j = c + \frac{1}{2}{h_y} + jh_y $$ -->
<!--  -->
<!-- L'expression semble quelque peu diff&#233;rente de \eqref{eq:GeneralMidpoint}, mais c'est &#224; cause de la notation: puisque nous nous int&#233;grons dans la direction \( y \) et que nous devrons travailler avec \( x \) et \( y \) comme coordonn&#233;es, nous devons utiliser \( n_y \) pour \( n \), \( h_y \) pour \( h \) et le compteur \( i \) est plus naturellement appel&#233; \( j \) lors de l'int&#233;gration dans \( y \). Les int&#233;grales dans la direction \( x \) utiliseront \( h_x \) et \( n_x \) pour \( h \) et \( n \), et \( i \) comme compteur. -->
<!--  -->
<!-- L'int&#233;grale double est \( \int_a^b g(x)dx \), qui peut &#234;tre approxim&#233;e par la m&#233;thode du point milieu: -->
<!-- $$\int_a^b g(x)dx \approx h_x \sum_{i=0}^{n_x-1} g(x_i),\quad x_i=a + \frac{1}{2}{h_x} + ih_x$$ -->
<!--  -->
<!-- En rassemblant les formules, nous arrivons &#224; la m&#233;thode du point milieu composite pour une double int&#233;grale: -->
<!-- !bt -->
<!-- \begin{align} -->
<!-- \int_a^b \int_c^d f(x,y) dydx &\approx -->
<!-- h_x \sum_{i=0}^{n_x-1} h_y \sum_{j=0}^{n_y-1} f(x_i,y_j)\nonumber\\ -->
<!-- &= -->
<!-- h_xh_y \sum_{i=0}^{n_x-1} \sum_{j=0}^{n_y-1} f(a + \frac{h_x}{2} + ih_x, c + \frac{h_y}{2} + jh_y) \<div id="eq:MidpointDouble"></div> -->
<!-- \end{align} -->
<!-- !et -->
<!-- La formule (<a href="#eq:MidpointDouble">eq:MidpointDouble</a>) peut &#233;galement &#234;tre d&#233;riv&#233;e directement dans le cas bidimensionnel en appliquant l'id&#233;e de la m&#233;thode du point milieu. Nous divisons le rectangle \( [a, b] \times [c, d] \) en \( nx \times ny \) cellules de taille &#233;gale. L'id&#233;e de la m&#233;thode du point milieu est d'approximer \( f \) par une constante sur chaque cellule et d'&#233;valuer la constante au point m&#233;dian. La cellule \( (i, j) \) occupe la zone -->
<!--  -->
<!-- $$[a+ih_x,a+(i+1)h_x]\times [c+jh_y, c+ (j+1)h_y],$$ -->
<!-- et le milieu est \( (x_i, y_j) \) avec -->
<!-- $$x_i=a + ih_x + \frac{1}{2}{h_x} ,\quad y_j = c + jh_y + \frac{1}{2}{h_y}$$ -->
<!-- L'int&#233;grale sur la cellule est donc \( h_xh_y f(x_i,y_j) \), et l'int&#233;grale double totale est la somme sur toutes les cellules, qui n'est rien d'autre que la formule (<a href="#eq:MidpointDouble">eq:MidpointDouble</a>). -->
<!-- === Programmation d'une double somme === -->
<!-- La formule (<a href="#eq:MidpointDouble">eq:MidpointDouble</a>) implique une double somme, qui est normalement impl&#233;ment&#233;e sous la forme d'une boucle double. Une fonction Python impl&#233;mentant (<a href="#eq:MidpointDouble">eq:MidpointDouble</a>) peut ressembler &#224; -->
<!-- !bc  pycod -->
<!-- def midpoint_double1(f, a, b, c, d, nx, ny): -->
<!-- hx = (b - a)/float(nx) -->
<!-- hy = (d - c)/float(ny) -->
<!-- I = 0 -->
<!-- for i in range(nx): -->
<!-- for j in range(ny): -->
<!-- xi = a + hx/2 + i*hx -->
<!-- yj = c + hy/2 + j*hy -->
<!-- I += hx*hy*f(xi, yj) -->
<!-- return I -->
<!-- !ec -->
<!-- Si cette fonction est stock&#233;e dans un fichier de module <code>midpoint_double.py</code>, nous pouvons calculer une int&#233;grale, par exemple, \( \int_2^3\int_0^2 (2x + y)dxdy=9 \) dans un shell interactif et d&#233;montrer que la fonction calcule le bon nombre: -->
<!-- !bc ipy -->
<!-- >>> from midpoint_double import midpoint_double1 -->
<!-- >>> def f(x, y): -->
<!-- ...     return 2*x + y -->
<!-- ... -->
<!-- >>> midpoint_double1(f, 0, 2, 2, 3, 5, 5) -->
<!-- 9.0 -->
<!-- !ec -->
<!-- === R&#233;utilisation du code pour les int&#233;grales unidimensionnelles === -->
<!-- Il est tr&#232;s naturel d'&#233;crire une m&#233;thode de point milieu bidimensionnelle comme nous l'avons fait dans la fonction <code>midpoint_double1</code> lorsque nous avons la formule (<a href="#eq:MidpointDouble">eq:MidpointDouble</a>). Cependant, nous pourrions &#233;galement demander, tout comme nous l'avons fait en math&#233;matiques, pouvons-nous r&#233;utiliser une impl&#233;mentation bien test&#233;e pour les int&#233;grales unidimensionnelles pour calculer les doubles int&#233;grales? Autrement dit, pouvons-nous utiliser la fonction <code>midpoint</code>. -->
<!--  -->
<!-- !bc pycod -->
<!-- def midpoint(f, a, b, n): -->
<!-- h = float(b-a)/n -->
<!-- result = 0 -->
<!-- for i in range(n): -->
<!-- result += f((a + h/2.0) + i*h) -->
<!-- result *= h -->
<!-- return result -->
<!-- !ec -->
<!--  -->
<!-- de la the section <a href="#sec:implementation">Impl&#233;mentation</a> "deux fois"? La r&#233;ponse est oui, si nous pensons comme nous l'avons fait dans les math&#233;matiques: calculer l'int&#233;grale double comme r&#232;gle du point milieu pour int&#233;grer \( g (x) \) et d&#233;finir \( g (x_i) \) en termes d'une r&#232;gle du point milieu sur \( f \) dans la coordonn&#233;e \( y \). -->
<!-- !bc pycod -->
<!-- def midpoint_double2(f, a, b, c, d, nx, ny): -->
<!-- def g(x): -->
<!-- return midpoint(lambda y: f(x, y), c, d, ny) -->
<!--  -->
<!-- return midpoint(g, a, b, nx) -->
<!-- !ec -->
<!-- L'avantage important de cette impl&#233;mentation est que nous r&#233;utilisons une fonction bien test&#233;e pour la r&#232;gle du point milieu unidimensionnelle standard et que nous appliquons la r&#232;gle unidimensionnelle exactement comme dans les math&#233;matiques. -->
<!-- === V&#233;rification via les fonctions de test === -->
<!-- Comment tester que nos fonctions pour la double int&#233;grale fonctionnent? Le meilleur test unitaire consiste &#224; trouver un probl&#232;me o&#249; l'erreur d'approximation num&#233;rique dispara&#238;t, car alors nous savons exactement quelle devrait &#234;tre la r&#233;ponse num&#233;rique. La r&#232;gle du point milieu est exacte pour les fonctions lin&#233;aires, quel que soit le nombre de sous-intervalles que nous utilisons. De plus, toute fonction lin&#233;aire bidimensionnelle \( f(x,y)=px+qy+r \) sera int&#233;gr&#233;e exactement par la r&#232;gle point milieu bidimensionnelle. Nous pouvons choisir \( f(x,y)=2x+y \) et cr&#233;er une fonction de test appropri&#233;e qui peut automatiquement v&#233;rifier nos deux impl&#233;mentations alternatives de la r&#232;gle du point milieu bidimensionnelle. La fonction de test devient: -->
<!-- !bc pycod -->
<!-- def test_midpoint_double(): -->
<!-- """Test that a linear function is integrated exactly.""" -->
<!-- def f(x, y): -->
<!-- return 2*x + y -->
<!--  -->
<!-- a = 0;  b = 2;  c = 2;  d = 3 -->
<!-- import sympy -->
<!-- x, y = sympy.symbols('x  y') -->
<!-- I_expected = sympy.integrate(f(x, y), (x, a, b), (y, c, d)) -->
<!-- # Test three cases: nx < ny, nx = ny, nx > ny -->
<!-- for nx, ny in (3, 5), (4, 4), (5, 3): -->
<!-- I_computed1 = midpoint_double1(f, a, b, c, d, nx, ny) -->
<!-- I_computed2 = midpoint_double2(f, a, b, c, d, nx, ny) -->
<!-- tol = 1E-14 -->
<!-- #print I_expected, I_computed1, I_computed2 -->
<!-- assert abs(I_computed1 - I_expected) < tol -->
<!-- assert abs(I_computed2 - I_expected) < tol -->
<!-- !ec -->
<!-- !bnotice Laisser parler les fonctions de test? -->
<!-- Si nous appelons la fonction <code>test_midpoint_double</code> ci-dessus et que rien ne se passe, nos impl&#233;mentations sont correctes. Cependant, il est quelque peu ennuyeux d'avoir une fonction compl&#232;tement silencieuse lorsqu'elle fonctionne sommes-nous s&#251;rs que tout est correctement calcul&#233;? Pendant le d&#233;veloppement, il est donc fortement recommand&#233; d'ins&#233;rer une instruction d'impression afin que nous puissions surveiller les calculs et &#234;tre convaincu que la fonction de test fait ce que nous voulons. Puisqu'une fonction de test ne doit avoir aucune instruction print(), nous la commentons simplement comme nous l'avons fait dans la fonction list&#233;e ci-dessus. -->
<!--  -->
<!-- !enotice -->
<!-- La m&#233;thode du trap&#232;ze peut &#234;tre utilis&#233;e comme alternative &#224; la m&#233;thode du point milieu. La d&#233;rivation d'une formule pour la double int&#233;grale et les impl&#233;mentations suivent exactement les m&#234;mes id&#233;es que nous avons expliqu&#233;es avec la m&#233;thode du point milieu, mais il y a plus de termes &#224; &#233;crire dans les formules. -->
<!-- ===== La r&#232;gle du point milieu pour une triple int&#233;grale ===== -->
<!-- === Th&#233;orie === -->
<!-- Une fois qu'une m&#233;thode qui fonctionne pour un probl&#232;me unidimensionnel est g&#233;n&#233;ralis&#233;e &#224; deux dimensions, il est g&#233;n&#233;ralement assez simple d'&#233;tendre la m&#233;thode &#224; trois dimensions. Cela sera maintenant d&#233;montr&#233; pour les int&#233;grales. Nous avons la triple int&#233;grale: -->
<!-- $$\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx$$ -->
<!-- et veulent approximer l'int&#233;grale par une r&#232;gle du point milieu. En suivant les id&#233;es de la double int&#233;grale, nous avons divis&#233; cette int&#233;grale en int&#233;grales unidimensionnelles: -->
<!-- !bt -->
<!-- \begin{align*} -->
<!-- p(x,y) &= \int_e^f g(x,y,z) dz\\ -->
<!-- q(x) &= \int_c^d p(x,y) dy\\ -->
<!-- \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx &= \int_a^b q(x)dx -->
<!-- \end{align*} -->
<!-- !et -->
<!-- Pour chacune de ces int&#233;grales unidimensionnelles, nous appliquons la r&#232;gle du point milieu: -->
<!-- !bt -->
<!-- \begin{align*} -->
<!-- p(x,y) = \int_e^f g(x,y,z) dz -->
<!-- &\approx \sum_{k=0}^{n_z-1} g(x,y,z_k), -->
<!-- \\ -->
<!-- q(x) = \int_c^d p(x,y) dy -->
<!-- &\approx \sum_{j=0}^{n_y-1} p(x,y_j), -->
<!-- \\ -->
<!-- \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx = \int_a^b q(x)dx -->
<!-- &\approx \sum_{i=0}^{n_x-1} q(x_i), -->
<!-- \end{align*} -->
<!-- !et -->
<!-- o&#249; -->
<!-- $$z_k=e + \frac{1}{2}h_z + kh_z,\quad y_j=c + \frac{1}{2}h_y + jh_y \quad -->
<!-- x_i=a + \frac{1}{2}h_x + ih_x$$ -->
<!-- En commen&#231;ant par la formule pour \( \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx \) et en ins&#233;rant les deux formules pr&#233;c&#233;dentes donne -->
<!-- !bt -->
<!-- \begin{align} -->
<!-- & \int_{a}^{b} \int_c^d \int_e^f g(x,y,z)\, dzdydx\approx\nonumber\\ -->
<!-- & h_xh_yh_z -->
<!-- \sum_{i=0}^{n_x-1}\sum_{j=0}^{n_y-1}\sum_{k=0}^{n_z-1} -->
<!-- g(a + \frac{1}{2}h_x + ih_x, -->
<!-- c + \frac{1}{2}h_y + jh_y, -->
<!-- e + \frac{1}{2}h_z + kh_z) \<div id="eq:midpointTriple"></div> -->
<!-- \end{align} -->
<!-- !et -->
<!-- Notez que nous pouvons appliquer les id&#233;es sous D&#233;rivation directe &#224; la fin de la the section <a href="#sec:midpointDouble">sec:midpointDouble</a> arrive &#224; (<a href="#eq:midpointTriple">eq:midpointTriple</a>) directement: diviser le domaine en \( n_x\times n_y\times n_z \) cellules de volumes \( h_xh_yh_z \); approximativement g par une constante, &#233;valu&#233;e au milieu \( (x_i,y_j,z_k) \), dans chaque cellule; et additionner les int&#233;grales de cellule \( h_xh_yh_zg(x_i,y_j,z_k) \). -->
<!-- === Impl&#233;mentation === -->
<!-- Nous suivons les id&#233;es pour les impl&#233;mentations de la r&#232;gle du point milieu pour une double int&#233;grale. Les fonctions correspondantes sont pr&#233;sent&#233;es ci-dessous et se trouvent dans le fichier <code>midpoint_triple.py</code>. -->
<!-- !bc pycod -->
<!-- def midpoint_triple1(g, a, b, c, d, e, f, nx, ny, nz): -->
<!-- hx = (b - a)/float(nx) -->
<!-- hy = (d - c)/float(ny) -->
<!-- hz = (f - e)/float(nz) -->
<!-- I = 0 -->
<!-- for i in range(nx): -->
<!-- for j in range(ny): -->
<!-- for k in range(nz): -->
<!-- xi = a + hx/2 + i*hx -->
<!-- yj = c + hy/2 + j*hy -->
<!-- zk = e + hz/2 + k*hz -->
<!-- I += hx*hy*hz*g(xi, yj, zk) -->
<!-- return I -->
<!--  -->
<!-- def midpoint(f, a, b, n): -->
<!-- h = float(b-a)/n -->
<!-- result = 0 -->
<!-- for i in range(n): -->
<!-- result += f((a + h/2.0) + i*h) -->
<!-- result *= h -->
<!-- return result -->
<!--  -->
<!-- def midpoint_triple2(g, a, b, c, d, e, f, nx, ny, nz): -->
<!-- def p(x, y): -->
<!-- return midpoint(lambda z: g(x, y, z), e, f, nz) -->
<!--  -->
<!-- def q(x): -->
<!-- return midpoint(lambda y: p(x, y), c, d, ny) -->
<!--  -->
<!-- return midpoint(q, a, b, nx) -->
<!--  -->
<!-- def test_midpoint_triple(): -->
<!-- """Test that a linear function is integrated exactly.""" -->
<!-- def g(x, y, z): -->
<!-- return 2*x + y - 4*z -->
<!--  -->
<!-- a = 0;  b = 2;  c = 2;  d = 3;  e = -1;  f = 2 -->
<!-- import sympy -->
<!-- x, y, z = sympy.symbols('x y z') -->
<!-- I_expected = sympy.integrate( -->
<!-- g(x, y, z), (x, a, b), (y, c, d), (z, e, f)) -->
<!-- for nx, ny, nz in (3, 5, 2), (4, 4, 4), (5, 3, 6): -->
<!-- I_computed1 = midpoint_triple1( -->
<!-- g, a, b, c, d, e, f, nx, ny, nz) -->
<!-- I_computed2 = midpoint_triple2( -->
<!-- g, a, b, c, d, e, f, nx, ny, nz) -->
<!-- tol = 1E-14 -->
<!-- print(I_expected, I_computed1, I_computed2) -->
<!-- assert abs(I_computed1 - I_expected) < tol -->
<!-- assert abs(I_computed2 - I_expected) < tol -->
<!--  -->
<!-- if __name__ == '__main__': -->
<!-- test_midpoint_triple() -->
<!-- !ec -->

<h1 id="___sec16" class="anchor">Int&#233;gration Monte Carlo </h1>
Les m&#233;thodes de Monte Carlo sont des techniques de calcul probabilistes. Au c&#339;ur, un algorithme de Monte Carlo repr&#233;sente de fa&#231;on al&#233;atoire certaines valeurs de l'espace de valeurs d'un param&#232;tre consid&#233;r&#233;. La combinaison de plusieurs param&#232;tres permet de tirer des conclusions stochastiques des relations. L'int&#233;gration des fonctions math&#233;matiques de la forme:
$$
\begin{equation*}
A = \int_a^b f(x) \cdot dx
\end{equation*}
$$

<p>
Pour effectuer une int&#233;gration, nous voulons savoir comment les valeurs s&#233;lectionn&#233;es au hasard sont r&#233;parties: lesquelles des valeurs sont &#233;gales ou inf&#233;rieures &#224; la valeur de la fonction et lesquelles sont sup&#233;rieures. Il s'agit d'une d&#233;cision binaire qui divise les valeurs al&#233;atoires en deux groupes. Du rapport de la taille des groupes, nous pouvons tirer nos conclusions.

<p>
Nous utilisons la fonction (int&#233;grande) comme crit&#232;re de d&#233;cision uniquement. L'algorithme ne nous fournit rien d'autre que des comptes/fr&#233;quences. La fermeture probabiliste est alors:
$$
\begin{equation*}
\frac{\textrm{cas favorables}} {\textrm{cas possibles}} = \frac {n}{N} = \frac{A_{sous\;la\;fonction}}{A_{aire \;totale}}
\end{equation*}
$$

La zone \( A_{sous\;la\;fonction} \) est la zone inconnue qui nous int&#233;resse. Pour \( A_{aire \;totale} \), nous choisissons arbitrairement une r&#233;gion simple, cette zone que nous pouvons calculer sans difficult&#233;s.

<h2 id="___sec17" class="anchor">Exemple: d&#233;termination de \( \pi \) </h2>
&#192; titre d'exemple, nous choisissons un cercle dont la fonction math&#233;matique est donn&#233;e par la premi&#232;re:
$$
\begin{align*}
x^2 + y^2 &= R^2 \\
y = f(x) &= \sqrt{R^2 - x^2}
\end{align*}
$$

Pour l'estimation de \( \pi \), l'aire du cercle est compar&#233;e &#224; l'aire du carr&#233; \( 2R \times 2R \), ce rapport est \( \pi / 4 \):
$$
\begin{align*}
A_{cercle} &= R^2 \cdot \pi \\
A_{carré} &= {(2R)}^2 = 4R^2
\end{align*}
$$

Nous g&#233;n&#233;rons au hasard \( (x_rand, y_rand) \)-points. Pour chaque point, nous devons d&#233;cider s'il se trouve &#224; l'int&#233;rieur ou &#224; l'ext&#233;rieur du cercle. Pour cela, nous utilisons la diff&#233;rence \( y_{rand} - f(x_{rand}) \), o&#249; \( f(x) = \sqrt{R^2 - x^2} \) est la fonction d'un cercle dans le premier quadrant. Nous pouvons compter le nombre de points &#224; l'int&#233;rieur du cercle. Nous pouvons compter le nombre de points &#224; l'int&#233;rieur du cercle. Le rapport \( n / N \) est suppos&#233; &#234;tre &#233;gal au rapport \( A_{cercle}/A_{carr&#233;} \)
$$
\begin{align*}
\frac {\textrm{n = (x,y)-points dans le cercle}}  {\textrm{N = (x,y)-points dans le carré}} &= \frac{A_{cercle}}{A_{carré}}
 = \frac {R^2 \cdot \pi}{4R^2 } = \frac {\pi}{4} \\
\pi &= 4\frac{n}{N}
\end{align*}
$$

<h2 id="___sec18" class="anchor">impl&#233;mentation </h2>
Nous avons vu l'int&#233;gration de Monte Carlo lorsque nous avons calcul&#233; \( \pi / 4 \) en calculant l'aire du quart de cercle unitaire.

<p>
Voici le code:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">## NOM DU PROGRAMME: MC_integral.py</span>
<span style="color: #408080; font-style: italic">#% IMPORTATION</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #BA2121; font-style: italic">&#39;&#39;&#39;</span>
<span style="color: #BA2121; font-style: italic">    fonction pour un cercle</span>
<span style="color: #BA2121; font-style: italic">    &#39;&#39;&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">1-</span>x<span style="color: #666666">*</span>x)

N <span style="color: #666666">=</span> <span style="color: #666666">10000</span>   <span style="color: #408080; font-style: italic"># nombre d&#39;essais</span>
x0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>
x1 <span style="color: #666666">=</span> <span style="color: #666666">1</span>

x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(x0, x1, <span style="color: #666666">0.01</span>)
y <span style="color: #666666">=</span> f(x)
fmax <span style="color: #666666">=</span> <span style="color: #008000">max</span>(y)
np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">6</span>)
x_rand <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> (x1 <span style="color: #666666">-</span> x0) <span style="color: #666666">*</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>rand(N)
y_rand <span style="color: #666666">=</span> fmax <span style="color: #666666">*</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>rand(N)
n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(y_rand <span style="color: #666666">-</span> f(x_rand) <span style="color: #666666">&lt;</span> <span style="color: #666666">0.0</span>) <span style="color: #408080; font-style: italic"># nombre de points dans le cercle</span>
<span style="color: #408080; font-style: italic">#----- Sortie et graphiques -------------------</span>
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;PI numpy       : &#39;</span>, np<span style="color: #666666">.</span>pi)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;PI monte carlo : &#39;</span>, <span style="color: #666666">4*</span>n<span style="color: #666666">/</span>N)
<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&#39;différence     : &#39;</span>, <span style="color: #666666">4*</span>n<span style="color: #666666">/</span>(N) <span style="color: #666666">-</span> np<span style="color: #666666">.</span>pi)

index_below <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(y_rand <span style="color: #666666">&lt;</span> f(x_rand))
index_above <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(y_rand <span style="color: #666666">&gt;=</span> f(x_rand))
plt<span style="color: #666666">.</span>figure(figsize<span style="color: #666666">=</span>(<span style="color: #666666">7</span>,<span style="color: #666666">7</span>))
plt<span style="color: #666666">.</span>plot(x,f(x),<span style="color: #BA2121">&#39;--k&#39;</span>)
plt<span style="color: #666666">.</span>scatter(x_rand[index_below], y_rand[index_below],
            c<span style="color: #666666">=</span><span style="color: #BA2121">&quot;r&quot;</span>, s <span style="color: #666666">=</span> <span style="color: #666666">5</span>, label <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Pts sous la courbe&quot;</span>)
plt<span style="color: #666666">.</span>scatter(x_rand[index_above], y_rand[index_above],
            c<span style="color: #666666">=</span><span style="color: #BA2121">&quot;b&quot;</span>, s <span style="color: #666666">=</span> <span style="color: #666666">5</span>, label <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Pts au-dessus de la courbe&quot;</span>)
plt<span style="color: #666666">.</span>legend(bbox_to_anchor<span style="color: #666666">=</span>(<span style="color: #666666">0.</span>, <span style="color: #666666">1.02</span>, <span style="color: #666666">1.</span>, <span style="color: #666666">.102</span>), ncol<span style="color: #666666">=2</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>PI numpy       :  3.141592653589793
PI monte carlo :  3.1436
différence     :  0.002007346410207056
</pre></div>
<p>
<br /><br /><center><p><img src="imgs/MC_integral.png" align="bottom" width=400></p></center><br /><br />

<p>
Nous pouvons g&#233;n&#233;raliser cette approche aux courbes autres que \( y = \sqrt{1-x^2} \). L'id&#233;e est la suivante: pour une courbe arbitraire, trouvez le rectangle qui la contient, g&#233;n&#233;rez un point al&#233;atoire dans ce rectangle et d&#233;terminez combien de points al&#233;atoires se trouvent sous la courbe.

<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright --> &copy; 2020, Ahmed Ammar. Released under CC Attribution 4.0 license
</center>


</body>
</html>
    

