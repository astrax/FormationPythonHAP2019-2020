<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #000080; font-weight: bold">TITLE: Intégration numérique</span>
<span style="color: #000080; font-weight: bold">AUTHOR:</span> Ahmed Ammar {copyright|CC BY} Email:ahmed.ammar@fst.utm.tn at Institut Préparatoire aux Études Scientifiques et Techniques, Université de Carthage.
<span style="color: #000080; font-weight: bold">DATE:</span> today

<span style="color: #000080; font-weight: bold">TOC:</span> on

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">======= Introduction =======</span>
L&#39;intégration numérique est un chapitre important de l&#39;analyse numérique et un outil indispensable en physique numérique. On intègre numériquement dans deux cas principaux:

* on ne peut pas intégrer analytiquement,
* l&#39;intégrande est fourni non pas sous la forme d&#39;une fonction mais de tableaux de mesures, cas d&#39;ailleurs le plus fréquent dans la vraie vie.
Les méthodes numériques d&#39;intégration d&#39;une fonction sont nombreuses et les techniques très diverses. Des très simples, comme la méthode des rectangles aux très complexes comme certaines variétés de la méthode de Monte-Carlo.

<span style="color: #8B008B; font-weight: bold">!split</span>
<span style="color: #000080; font-weight: bold">======= Idées de base de l&#39;intégration numérique =======</span>
Nous considérons l&#39;intégrale
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span> \label{eq:ExampleIntegral}
\int_a^b f(x)dx
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
La plupart des méthodes numériques de calcul de cette intégrale divisent l&#39;intégrale d&#39;origine en une somme de plusieurs intégrales, chacune couvrant une partie plus petite de l&#39;intervalle d&#39;intégration d&#39;origine $[a, b]$. Cette réécriture de l&#39;intégrale est basée sur une sélection de points d&#39;intégration $x_i$, $i = 0,1,…, n$ qui sont répartis sur l&#39;intervalle $[a, b]$. Les points d&#39;intégration peuvent ou non être répartis uniformément. Une distribution uniforme simplifie les expressions et est souvent suffisante, nous nous limiterons donc principalement à ce choix. Les points d&#39;intégration sont ensuite calculés comme:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span>
x_i = a + ih,\quad i = 0,1,\ldots,n
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
où
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span>
h = \frac{b-a}{n}
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Compte tenu des points d&#39;intégration, l&#39;intégrale d&#39;origine est réécrite sous la forme d&#39;une somme d&#39;intégrales, chaque intégrale étant calculée sur le sous-intervalle entre deux points d&#39;intégration consécutifs. L&#39;intégrale dans (ref{eq:ExampleIntegral}) est donc exprimée comme:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span> \label{eq:SumIntegrals}
\int_a^b f(x)dx =
\int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx + \ldots +
\int_{x_{n-1}}^{x_n} f(x)dx
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Notez que $x_0 = a$ et $x_n = b$.

En partant de (ref{eq:SumIntegrals}), les différentes méthodes d&#39;intégration différeront dans la façon dont elles approchent chaque intégrale du côté droit. L&#39;idée fondamentale est que chaque terme est une intégrale sur un petit intervalle $[x_i, x_{i + 1}]$, et sur ce petit intervalle, il est logique d&#39;approximer f par une forme simple, disons une constante, une ligne droite ou une parabole , que nous pouvons facilement intégrer à la main. Les détails deviendront clairs dans les exemples à venir.
<span style="color: #000080; font-weight: bold">===== Exemple de calcul =====</span>
Pour comprendre et comparer les méthodes d&#39;intégration numérique, il est avantageux d&#39;utiliser une intégrale spécifique pour les calculs et les illustrations graphiques. En particulier, nous voulons utiliser une intégrale que nous pouvons calculer à la main de sorte que la précision des méthodes d&#39;approximation puisse être facilement évaluée. Notre intégrale spécifique est tirée de la physique de base. Supposons que vous accélérez votre voiture du repos et demandez-vous jusqu&#39;où vous allez en $T$ secondes. La distance est donnée par l&#39;intégrale $\int_0^T v(t)dt$ , où $v (t)$ est la vitesse en fonction du temps. Une fonction de vitesse en augmentation rapide pourrait être:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span>
v\left(t\right) = 3t^{2}e^{t^3}\thinspace
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
La distance après une seconde est
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span> \label{eq:SpeedIntegral}
\int_0^1 v(t)dt
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
qui est l&#39;intégrale que nous cherchons à calculer par des méthodes numériques. Heureusement, l&#39;expression choisie de la vitesse a une forme qui permet de calculer facilement la primitive comme
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span>
V(t) = e^{t^3}-1
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Nous pouvons donc calculer la valeur exacte de l&#39;intégrale comme $V (1) −V (0) ≈1.718$ (arrondi à 3 décimales pour plus de commodité).
<span style="color: #000080; font-weight: bold">======= La règle du trapèze composite =======</span>
L&#39;intégrale $\int_a^b f(x)dx$ peut être interprété comme l&#39;aire entre l&#39;axe des x et le graphique $y = f (x)$ de fonction à intégrer. La figure ref{fig:integral_of_f} illustre cette zone de choix (ref{eq:SpeedIntegral}). Le calcul de l&#39;intégrale $\int_0^1f(t)dt$ revient à calculer l&#39;aire de la zone hachurée.
<span style="color: #658b00">FIGURE:[imgs/integral_of_f, width=400 frac=0.7] L&#39;intégrale de $v (t)$ interprétée comme l&#39;aire sous le graphique de $v$. label{fig:integral_of_f}</span>

Si nous remplaçons le vrai graphique de la figure ref{fig:integral_of_f} par un ensemble de segments de ligne droite, nous pouvons voir la zone plutôt comme composée de trapèzes, dont les zones sont faciles à calculer. Ceci est illustré sur la figure ref{fig:viz_trapezoidal}, où 4 segments de ligne droite donnent naissance à 4 trapèzes, couvrant les intervalles de temps $[0,0.2)$, $[0.2,0.6)$, $[0.6,0.8)$ et $[0.8,1.0]$. Notez que nous en avons profité pour démontrer les calculs avec des intervalles de temps de tailles différentes.
<span style="color: #658b00">FIGURE:[imgs/viz_trapezoidal, width=400 frac=0.7] Calculer approximativement l&#39;intégrale d&#39;une fonction comme la somme des aires des trapèzes. label{fig:viz_trapezoidal}</span>
Les aires des 4 trapèzes représentés sur la figure ref{fig:viz_trapezoidal} constituent maintenant notre approximation de l&#39;intégrale (ref{eq:SpeedIntegral}):
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align}</span>
\int_0^1 v(t)dt &amp;\approx
h_1 (\frac{v(0)+v(0.2)}{2}) + h_2 (\frac{v(0.2)+v(0.6)}{2}) \nonumber  \\
&amp;+ h_3 (\frac{v(0.6)+v(0.8)}{2}) + h_4 (\frac{v(0.8)+v(1.0)}{2})
\label{eq:trapezoids}
<span style="color: #658b00">\end{align}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
où
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align}</span>
h_1 &amp;= (0.2 - 0.0) \label{eq:h1}\\
h_2 &amp;= (0.6 - 0.2)  \label{eq:h2}\\
h_3 &amp;= (0.8 - 0.6)  \label{eq:h3}\\
h_4 &amp;= (1.0 - 0.8) \label{eq:h4}
<span style="color: #658b00">\end{align}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Avec $v(t) = 3t^{2}e^{t^3}$, chaque terme dans (ref{eq:trapezoids}) est facilement calculé et notre calcul approximatif donne
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span>
\int_0^1 v(t)dt \approx 1.895
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Par rapport à la vraie réponse de $1.718$, cela est d&#39;environ $10 \%$. Cependant, notez que nous avons utilisé seulement 4 trapèzes pour approximer la zone. Avec plus de trapèzes, l&#39;approximation serait devenue meilleure, puisque les segments de droite du côté supérieur des trapèzes suivraient alors le graphique de plus près. Faire un autre calcul avec plus de trapèzes n&#39;est pas trop tentant pour un humain paresseux, mais c&#39;est un travail parfait pour un ordinateur! Dérivons donc les expressions d&#39;approximation de l&#39;intégrale par un nombre arbitraire de trapèzes.
<span style="color: #000080; font-weight: bold">===== La formule générale =====</span>
Pour une fonction donnée $f (x)$, nous voulons approximer l&#39;intégrale $\int_a^bf(x)dx$ par $n$ trapèzes (de largeur égale). Nous commençons par (ref{eq:SumIntegrals}) et approchons chaque intégrale du côté droit avec un seul trapèze. En détail,
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align}</span>
\int_a^b f(x)\,dx &amp;= \int_{x_0}^{x_1} f(x) dx + \int_{x_1}^{x_2} f(x) dx + \ldots + \int_{x_{n-1}}^{x_n} f(x) dx,     \nonumber \\
                  &amp;\approx h \frac{f(x_0) + f(x_1)}{2} +
		  h \frac{f(x_1) + f(x_2)}{2} + \ldots + \nonumber \\
		  &amp;\quad h \frac{f(x_{n-1}) + f(x_n)}{2} \label{eq:SumTrapezes}
<span style="color: #658b00">\end{align}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
En simplifiant le côté droit de (ref{eq:SumTrapezes}), nous obtenons
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span>
\int_a^b f(x)\,dx \approx \\
\frac{h}{2}\left[f(x_0) + 2 f(x_1) + 2 f(x_2) + \ldots + 2 f(x_{n-1}) + f(x_n)\right]
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
qui est écrit de façon plus compacte comme
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span> \label{eq:GenralIntegral}
\int_a^b f(x)\,dx \approx h \left[\frac{1}{2}f(x_0) + \sum_{i=1}^{n-1}f(x_i) + \frac{1}{2}f(x_n) \right]
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
<span style="color: #8B008B; font-weight: bold">!bnotice</span> Règles d&#39;intégration composites
Le mot composite est souvent utilisé lorsqu&#39;une méthode d&#39;intégration numérique est appliquée avec plus d&#39;un sous-intervalle.
à vrai dire alors, écrire, par exemple, &quot;la méthode du trapèze&quot;, devrait impliquer l&#39;utilisation d&#39;un seul trapèze, tandis que &quot;la méthode du trapèze composite&quot; est le nom le plus correct lorsque plusieurs trapèzes sont utilisés. Cependant, cette convention de dénomination n&#39;est pas toujours suivie, donc dire que &quot;la méthode du trapèze&quot; peut pointer vers un seul trapèze ainsi que la règle composite avec de nombreux trapèzes.
<span style="color: #8B008B; font-weight: bold">!enotice</span>
<span style="color: #000080; font-weight: bold">===== Implémentation =====</span>
<span style="color: #000080; font-weight: bold">=== Implémentation spécifique ou générale? ===</span>
Supposons que notre objectif principal était de calculer l&#39;intégrale spécifique $\int_0^1 v(t)dt$ avec $v(t)=3t^2e^{t^3}$. D&#39;abord, nous avons joué avec un simple calcul de main pour voir de quoi il s&#39;agissait, avant de développer (comme c&#39;est souvent le cas en mathématiques) une formule générale (ref{eq:GenralIntegral}) pour l&#39;intégrale générale ou «abstraite» $\int_a^bf(x)dx$. Pour résoudre notre problème spécifique $\int_0^1 v(t)dt$, nous devons ensuite appliquer la formule générale (ref{eq:GenralIntegral}) aux données données (fonction et limites intégrales) dans notre problème. Bien que simples en principe, les étapes pratiques sont déroutantes pour beaucoup car la notation dans le problème abstrait de (ref{eq:GenralIntegral}) diffère de la notation dans notre problème spécial. Clairement, les $f$, $x$ et $h$ dans (ref{eq:GenralIntegral}) correspondent à $v$, $t$ et peut-être $\Delta t$ pour la largeur du trapèze dans notre problème spécial.
<span style="color: #8B008B; font-weight: bold">!bquestion</span> Le dilemme du programmeur
o Faut-il écrire un programme spécial pour l&#39;intégrale spéciale, en utilisant les idées de la règle générale (ref{eq:GenralIntegral}), mais en remplaçant $f$ par $v$, $x$ par $t$ et $h$ par $\Delta t$?
o Faut-il implémenter la méthode générale (ref{eq:GenralIntegral}) telle qu&#39;elle se présente dans une fonction générale `trapeze(f, a, b, n)` et résoudre le problème spécifique en question par un appel spécialisé à cette fonction?

_L&#39;alternative 2 est toujours le meilleur choix!_
<span style="color: #8B008B; font-weight: bold">!equestion</span>

La première alternative dans l&#39;encadré ci-dessus semble moins abstraite et donc plus attrayante pour beaucoup. Néanmoins, comme nous l&#39;espérons, cela sera évident à partir des exemples, la deuxième alternative est en fait la plus simple et la plus fiable d&#39;un point de vue mathématique et de programmation. Ces auteurs affirmeront que la deuxième alternative est l&#39;essence même du pouvoir des mathématiques, tandis que la première alternative est la source de beaucoup de confusion sur les mathématiques!
<span style="color: #000080; font-weight: bold">=== Implémentation avec fonctions ===</span>
Pour l&#39;intégrale $\int_a^bf(x)dx$ calculée par la formule (ref{eq:GenralIntegral}), nous voulons que le trapèze de la fonction Python correspondante prenne tout $f$, $a$, $b$ et $n$ en entrée et renvoie l&#39;approximation à l&#39;intégrale.

Nous écrivons une fonction Python `trapeze()` dans un fichier `trapeze_integral.py` aussi proche que possible de la formule (ref{eq:GenralIntegral}), en nous assurant que les noms de variables correspondent à la notation mathématique:

<span style="color: #800080; font-weight: bold">@@@CODE scripts/trapeze_integral.py fromto:## NOM@def application()</span>
<span style="color: #000080; font-weight: bold">=== Résoudre notre problème spécifique en une session ===</span>
Le simple fait d&#39;avoir la fonction `trapeze()` comme seul contenu d&#39;un fichier `trapeze_integral.py` fait automatiquement de ce fichier un module que nous pouvons importer et tester dans une session interactive:
<span style="color: #8B008B; font-weight: bold">!bc</span> ipy
In [3]: from trapeze_integral import trapeze
In [4]: from math import exp
In [5]: v = lambda t: 3*(t**2)*exp(t**3)
In [6]: n = 4
In [7]: numerical = trapeze(v, 0, 1, n)
In [8]: numerical
Out[8]: 1.9227167504675762
<span style="color: #8B008B; font-weight: bold">!ec</span>
Calculons l&#39;expression exacte et l&#39;erreur dans l&#39;approximation:
<span style="color: #8B008B; font-weight: bold">!bc</span> ipy
In [9]: V = lambda t: exp(t**3) - 1
In [10]: exact = V(1) - V(0)
In [11]: exact - numerical
Out[11]: -0.20443492200853108
<span style="color: #8B008B; font-weight: bold">!ec</span>
Cette erreur est-elle convaincante? On peut essayer un $n$ plus grand:
<span style="color: #8B008B; font-weight: bold">!bc</span> ipy
In [12]: numerical = trapeze(v, 0, 1, n=400)
In [13]: exact - numerical
Out[13]: -2.1236490512777095e-05
<span style="color: #8B008B; font-weight: bold">!ec</span>
Heureusement, beaucoup plus de trapèzes donnent une erreur beaucoup plus petite.
<span style="color: #000080; font-weight: bold">=== Résoudre notre problème spécifique dans un programme ===</span>
Au lieu de calculer notre problème spécial dans une session interactive, nous pouvons le faire dans un programme. Comme toujours, un morceau de code faisant une chose particulière est mieux isolé en tant que fonction même si nous ne voyons aucune raison future d&#39;appeler la fonction plusieurs fois et même si nous n&#39;avons pas besoin d&#39;arguments pour paramétrer ce qui se passe à l&#39;intérieur de la fonction. Dans le cas présent, nous mettons simplement les instructions que nous aurions autrement mises dans un programme principal, à l&#39;intérieur d&#39;une fonction:

<span style="color: #800080; font-weight: bold">@@@CODE scripts/trapeze_integral.py fromto:def application@if</span>

Maintenant, nous calculons notre problème spécial en appelant `application()` comme la seule instruction du programme principal.

<span style="color: #000080; font-weight: bold">=== Faire un module ===</span>
Lorsque nous avons les différentes parties de notre programme comme une collection de fonctions, il est très simple de créer un *module* qui peut être importé dans d&#39;autres programmes. Ce fait, avoir notre code comme module, signifie que la fonction `trapeze()` peut facilement être réutilisée par d&#39;autres programmes pour résoudre d&#39;autres problèmes. Les exigences d&#39;un module sont simples: mettez tout à l&#39;intérieur des fonctions et laissez les appels de fonction dans le programme principal être dans le soi-disant *bloc de test*:
<span style="color: #800080; font-weight: bold">@@@CODE scripts/trapeze_integral.py fromto:if@</span>

Le test `if` est vrai si le fichier de module, `trapeze_integral.py`, est exécuté en tant que programme et faux si le module est importé dans un autre programme. Par conséquent, lorsque nous effectuons une importation: `from trapeze_integral import trapeze` dans un fichier, le test échoue et `application()` n&#39;est pas appelée, c&#39;est-à-dire que notre problème spécial n&#39;est pas résolu et n&#39;imprime rien à l&#39;écran. D&#39;un autre côté, si nous exécutons `trapeze_integral.py` dans la fenêtre du terminal, la condition de test est positive, `application()` est appelée et nous obtenons une sortie dans la fenêtre:

<span style="color: #8B008B; font-weight: bold">!bc</span> pycod-text
Terminal&gt; python trapeze_integral.py
n: 400
n=400: 1.7183030649495579, error: -2.12365e-05
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #000080; font-weight: bold">======= La méthode du point milieu composite =======</span>
<span style="color: #000080; font-weight: bold">===== L&#39;idée =====</span>
Plutôt que d&#39;approximer l&#39;aire sous une courbe par des trapèzes, nous pouvons utiliser des rectangles simples. Il peut sembler moins précis d&#39;utiliser des lignes horizontales et non des lignes obliques suivant la fonction à intégrer, mais une méthode d&#39;intégration basée sur des rectangles (la méthode du point milieu) est en fait légèrement plus précise que celle basée sur des trapèzes!

Dans la méthode du milieu, nous construisons un rectangle pour chaque sous-intervalle où la hauteur est égale à $f$ au milieu du sous-intervalle. Faisons-le pour quatre rectangles, en utilisant les mêmes sous-intervalles que nous avions pour les calculs manuels avec la méthode du trapèze: $[0,0.2)$, $[0.2,0.6)$, $[0.6,0.8)$ et $[0.8,1.0]$. On a
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align}</span>
\int_0^1 f(t)dt &amp;\approx
   h_1 f\left(\frac{0 + 0.2}{2}\right) +
   h_2 f\left(\frac{0.2 + 0.6}{2}\right) \nonumber  \\
&amp;+ h_3 f\left(\frac{0.6 + 0.8}{2}\right) +
   h_4 f\left(\frac{0.8 + 1.0}{2}\right)
<span style="color: #658b00">\end{align}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
où $h_1$, $h_2$, $h_3$ et $h_4$ sont les largeurs des sous-intervalles, utilisées précédemment avec la méthode du trapèze et définies dans (ref{eq:h1})-(ref{eq:h4}).

<span style="color: #658b00">FIGURE:[imgs/viz_midpoint, width=400 frac=0.7] Calcul approximatif de l&#39;intégrale d&#39;une fonction comme la somme des aires des rectangles. label{fig:viz_midpoint}</span>

Avec $f(t) = 3t^{2}e^{t^3}$, l&#39;approximation devient $1.632$. Comparé à la vraie réponse ($1.718$), c&#39;est environ $5 \%$ trop petit, mais c&#39;est mieux que ce que nous avons obtenu avec la méthode trapézoïdale ($10 \%$) avec les mêmes sous-intervalles. Plus de rectangles donnent une meilleure approximation.

<span style="color: #000080; font-weight: bold">===== La formule générale =====</span>
Dérivons une formule pour la méthode du milieu basée sur $n$ rectangles d&#39;égale largeur:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align}</span>
\int_a^b f(x)\,dx &amp;= \int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx +
                     \ldots + \int_{x_{n-1}}^{x_n} f(x)dx,     \nonumber \\
                  &amp;\approx h f\left(\frac{x_0 + x_1}{2}\right) +
                   h f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                   h f\left(\frac{x_{n-1} + x_n}{2}\right) \\
                  &amp;\approx h \left(f\left(\frac{x_0 + x_1}{2}\right) +
                  f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                  f\left(\frac{x_{n-1} + x_n}{2}\right)\right)
<span style="color: #658b00">\end{align}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Cette somme peut être écrite de façon plus compacte comme
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation}</span> \label{eq:GeneralMidpoint}
\int_a^b f(x) dx \approx h \sum_{i=0}^{n-1}f(x_i)
<span style="color: #658b00">\end{equation}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
où $x_i = \left(a + \frac{h}{2}\right) + ih$.

<span style="color: #000080; font-weight: bold">===== Implémentation =====</span>
<span style="color: #658b00">label{sec:implementation}</span>
Nous suivons les conseils et les enseignements tirés de l&#39;implémentation de la méthode trapèze et réalisons une fonction `midpoint(f, a, b, n)` (dans un fichier `midpoint_integral.py`) pour implémenter la formule générale (ref{eq:GeneralMidpoint}):

<span style="color: #800080; font-weight: bold">@@@CODE scripts/midpoint_integral.py fromto:## NOM@def application()</span>

Nous pouvons tester la fonction comme nous l&#39;avons expliqué pour la méthode du trapèze similaire. L&#39;erreur dans notre problème particulier $\int_0^1 3t^2e^{t^3}dt$ avec quatre intervalles est maintenant d&#39;environ $0.1$ contrairement à $0.2$ pour la règle du trapèze. Les différences sont rarement d&#39;une importance pratique, et sur un ordinateur portable, nous pouvons facilement utiliser $n = 10^6$ et obtenir la réponse avec une erreur d&#39;environ $10^{-12}$ en quelques secondes.
<span style="color: #000080; font-weight: bold">===== Comparaison des méthodes du trapèze et du point milieu =====</span>
L&#39;exemple suivant montre la facilité avec laquelle nous pouvons combiner les fonctions `trapeze()` et `midpoint()` pour comparer les deux méthodes dans le fichier `compare_integration_methods.py`:

<span style="color: #800080; font-weight: bold">@@@CODE scripts/compare_integration_methods.py</span>

Notez les efforts mis en forme agréable - la sortie devient
<span style="color: #8B008B; font-weight: bold">!bc</span> shell
      n      point milieu     trapèze
      2 0.8842000076332692 0.8770372606158094
      4 0.8827889485397279 0.8806186341245393
      8 0.8822686991994210 0.8817037913321336
     16 0.8821288703366458 0.8819862452657772
     32 0.8820933014203766 0.8820575578012112
     64 0.8820843709743319 0.8820754296107942
    128 0.8820821359746071 0.8820799002925637
    256 0.8820815770754198 0.8820810181335849
    512 0.8820814373412922 0.8820812976045025
   1024 0.8820814024071774 0.8820813674728968
   2048 0.8820813936736116 0.8820813849400392
   4096 0.8820813914902204 0.8820813893068272
   8192 0.8820813909443684 0.8820813903985197
  16384 0.8820813908079066 0.8820813906714446
  32768 0.8820813907737911 0.8820813907396778
 131072 0.8820813907631487 0.8820813907610036
 262144 0.8820813907625702 0.8820813907620528
 524288 0.8820813907624605 0.8820813907623183
1048576 0.8820813907624268 0.8820813907623890
<span style="color: #8B008B; font-weight: bold">!ec</span>
Une inspection visuelle des chiffres montre à quelle vitesse les chiffres se stabilisent dans les deux méthodes. Il semble que 13 chiffres se soient stabilisés dans les deux dernières lignes.

<span style="color: #8B008B; font-weight: bold">!bnotice</span> Remarque
Les méthodes du trapèze et du point milieu ne sont que deux exemples dans une jungle de règles d&#39;intégration numérique. D&#39;autres méthodes célèbres sont la règle de Simpson et la quadrature de Gauss. Ils fonctionnent tous de la même manière:
$$\int_a^b f(x)dx \approx \sum_{i=0}^{n-1} w_if(x_i)$$
Autrement dit, l&#39;intégrale est approximée par une somme d&#39;évaluations de fonctions, où chaque évaluation $f (x_i)$ reçoit un poids $w_i$. Les différentes méthodes diffèrent par la façon dont elles construisent les points d&#39;évaluation $x_i$ et les poids $w_i$. Nous avons utilisé des points $x_i$ également espacés, mais une précision plus élevée peut être obtenue en optimisant l&#39;emplacement de $x_i$.
<span style="color: #8B008B; font-weight: bold">!enotice</span>

<span style="color: #228B22"># ======= Intégrales doubles et triples =======</span>
<span style="color: #228B22"># ===== La règle du point milieu pour une double intégrale =====</span>
<span style="color: #228B22"># label{sec:midpointDouble}</span>
<span style="color: #228B22"># Étant donné une intégrale double sur un domaine rectangulaire $[a, b] \times [c, d]$,</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># $$\int_a^b \int_c^d f(x,y) dydx$$</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># comment approcher cette intégrale par des méthodes numériques?</span>
<span style="color: #228B22"># === Dérivation via des intégrales unidimensionnelles ===</span>
<span style="color: #228B22"># Puisque nous savons comment traiter les intégrales à une variable, une approche fructueuse consiste à considérer l&#39;intégrale double comme deux intégrales, chacune à une variable, qui peut être approximée numériquement par les formules unidimensionnelles précédentes. À cette fin, nous introduisons une fonction intermédiaire $g (x)$ et écrivons</span>
<span style="color: #228B22"># $$\int_a^b \int_c^d f(x,y) dydx = \int_a^b g(x)dx,\quad</span>
<span style="color: #228B22"># g(x) = \int_c^d f(x,y) dy$$</span>
<span style="color: #228B22"># Chacune des intégrales</span>
<span style="color: #228B22"># $$ \int_a^b g(x)dx,\quad</span>
<span style="color: #228B22"># g(x) = \int_c^d f(x,y) dy$$</span>
<span style="color: #228B22"># peut être discrétisé par n&#39;importe quelle règle d&#39;intégration numérique pour une intégrale dans une variable. Utilisons la méthode du point milieu (ref{eq:GeneralMidpoint}) et commençons par $g(x)=\int_c^d f(x,y)dy$. Nous introduisons $n_y$ intervalles sur $[c, d]$ de longueur $h_y$. La règle du point milieu pour cette intégrale devient alors</span>
<span style="color: #228B22"># $$g(x) = \int_c^d f(x,y) dy \approx  h_y \sum_{j=0}^{n_y-1} f(x,y_j),</span>
<span style="color: #228B22"># \quad y_j = c + \frac{1}{2}{h_y} + jh_y $$</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># L&#39;expression semble quelque peu différente de (ref{eq:GeneralMidpoint}), mais c&#39;est à cause de la notation: puisque nous nous intégrons dans la direction $y$ et que nous devrons travailler avec $x$ et $y$ comme coordonnées, nous devons utiliser $n_y$ pour $n$, $h_y$ pour $h$ et le compteur $i$ est plus naturellement appelé $j$ lors de l&#39;intégration dans $y$. Les intégrales dans la direction $x$ utiliseront $h_x$ et $n_x$ pour $h$ et $n$, et $i$ comme compteur.</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># L&#39;intégrale double est $\int_a^b g(x)dx$, qui peut être approximée par la méthode du point milieu:</span>
<span style="color: #228B22"># $$\int_a^b g(x)dx \approx h_x \sum_{i=0}^{n_x-1} g(x_i),\quad x_i=a + \frac{1}{2}{h_x} + ih_x$$</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># En rassemblant les formules, nous arrivons à la méthode du point milieu composite pour une double intégrale:</span>
<span style="color: #228B22"># !bt</span>
<span style="color: #228B22"># \begin{align}</span>
<span style="color: #228B22"># \int_a^b \int_c^d f(x,y) dydx &amp;\approx</span>
<span style="color: #228B22"># h_x \sum_{i=0}^{n_x-1} h_y \sum_{j=0}^{n_y-1} f(x_i,y_j)\nonumber\\</span>
<span style="color: #228B22"># &amp;=</span>
<span style="color: #228B22"># h_xh_y \sum_{i=0}^{n_x-1} \sum_{j=0}^{n_y-1} f(a + \frac{h_x}{2} + ih_x, c + \frac{h_y}{2} + jh_y) \label{eq:MidpointDouble}</span>
<span style="color: #228B22"># \end{align}</span>
<span style="color: #228B22"># !et</span>
<span style="color: #228B22"># La formule (ref{eq:MidpointDouble}) peut également être dérivée directement dans le cas bidimensionnel en appliquant l&#39;idée de la méthode du point milieu. Nous divisons le rectangle $[a, b] \times [c, d]$ en $nx \times ny$ cellules de taille égale. L&#39;idée de la méthode du point milieu est d&#39;approximer $f$ par une constante sur chaque cellule et d&#39;évaluer la constante au point médian. La cellule $(i, j)$ occupe la zone</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># $$[a+ih_x,a+(i+1)h_x]\times [c+jh_y, c+ (j+1)h_y],$$</span>
<span style="color: #228B22"># et le milieu est $(x_i, y_j)$ avec</span>
<span style="color: #228B22"># $$x_i=a + ih_x + \frac{1}{2}{h_x} ,\quad y_j = c + jh_y + \frac{1}{2}{h_y}$$</span>
<span style="color: #228B22"># L&#39;intégrale sur la cellule est donc $h_xh_y f(x_i,y_j)$, et l&#39;intégrale double totale est la somme sur toutes les cellules, qui n&#39;est rien d&#39;autre que la formule (ref{eq:MidpointDouble}).</span>
<span style="color: #228B22"># === Programmation d&#39;une double somme ===</span>
<span style="color: #228B22"># La formule (ref{eq:MidpointDouble}) implique une double somme, qui est normalement implémentée sous la forme d&#39;une boucle double. Une fonction Python implémentant (ref{eq:MidpointDouble}) peut ressembler à</span>
<span style="color: #228B22"># !bc  pycod</span>
<span style="color: #228B22"># def midpoint_double1(f, a, b, c, d, nx, ny):</span>
<span style="color: #228B22">#     hx = (b - a)/float(nx)</span>
<span style="color: #228B22">#     hy = (d - c)/float(ny)</span>
<span style="color: #228B22">#     I = 0</span>
<span style="color: #228B22">#     for i in range(nx):</span>
<span style="color: #228B22">#         for j in range(ny):</span>
<span style="color: #228B22">#             xi = a + hx/2 + i*hx</span>
<span style="color: #228B22">#             yj = c + hy/2 + j*hy</span>
<span style="color: #228B22">#             I += hx*hy*f(xi, yj)</span>
<span style="color: #228B22">#     return I</span>
<span style="color: #228B22"># !ec</span>
<span style="color: #228B22"># Si cette fonction est stockée dans un fichier de module `midpoint_double.py`, nous pouvons calculer une intégrale, par exemple, $\int_2^3\int_0^2 (2x + y)dxdy=9$ dans un shell interactif et démontrer que la fonction calcule le bon nombre:</span>
<span style="color: #228B22"># !bc ipy</span>
<span style="color: #228B22"># &gt;&gt;&gt; from midpoint_double import midpoint_double1</span>
<span style="color: #228B22"># &gt;&gt;&gt; def f(x, y):</span>
<span style="color: #228B22"># ...     return 2*x + y</span>
<span style="color: #228B22"># ...</span>
<span style="color: #228B22"># &gt;&gt;&gt; midpoint_double1(f, 0, 2, 2, 3, 5, 5)</span>
<span style="color: #228B22"># 9.0</span>
<span style="color: #228B22"># !ec</span>
<span style="color: #228B22"># === Réutilisation du code pour les intégrales unidimensionnelles ===</span>
<span style="color: #228B22"># Il est très naturel d&#39;écrire une méthode de point milieu bidimensionnelle comme nous l&#39;avons fait dans la fonction `midpoint_double1` lorsque nous avons la formule (ref{eq:MidpointDouble}). Cependant, nous pourrions également demander, tout comme nous l&#39;avons fait en mathématiques, pouvons-nous réutiliser une implémentation bien testée pour les intégrales unidimensionnelles pour calculer les doubles intégrales? Autrement dit, pouvons-nous utiliser la fonction `midpoint`.</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># !bc pycod</span>
<span style="color: #228B22"># def midpoint(f, a, b, n):</span>
<span style="color: #228B22">#     h = float(b-a)/n</span>
<span style="color: #228B22">#     result = 0</span>
<span style="color: #228B22">#     for i in range(n):</span>
<span style="color: #228B22">#         result += f((a + h/2.0) + i*h)</span>
<span style="color: #228B22">#     result *= h</span>
<span style="color: #228B22">#     return result</span>
<span style="color: #228B22"># !ec</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># de la section ref{sec:implementation} &quot;deux fois&quot;? La réponse est oui, si nous pensons comme nous l&#39;avons fait dans les mathématiques: calculer l&#39;intégrale double comme règle du point milieu pour intégrer $g (x)$ et définir $g (x_i)$ en termes d&#39;une règle du point milieu sur $f$ dans la coordonnée $y$.</span>
<span style="color: #228B22"># !bc pycod</span>
<span style="color: #228B22"># def midpoint_double2(f, a, b, c, d, nx, ny):</span>
<span style="color: #228B22">#     def g(x):</span>
<span style="color: #228B22">#         return midpoint(lambda y: f(x, y), c, d, ny)</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22">#     return midpoint(g, a, b, nx)</span>
<span style="color: #228B22"># !ec</span>
<span style="color: #228B22"># L&#39;avantage important de cette implémentation est que nous réutilisons une fonction bien testée pour la règle du point milieu unidimensionnelle standard et que nous appliquons la règle unidimensionnelle exactement comme dans les mathématiques.</span>
<span style="color: #228B22"># === Vérification via les fonctions de test ===</span>
<span style="color: #228B22"># Comment tester que nos fonctions pour la double intégrale fonctionnent? Le meilleur test unitaire consiste à trouver un problème où l&#39;erreur d&#39;approximation numérique disparaît, car alors nous savons exactement quelle devrait être la réponse numérique. La règle du point milieu est exacte pour les fonctions linéaires, quel que soit le nombre de sous-intervalles que nous utilisons. De plus, toute fonction linéaire bidimensionnelle $f(x,y)=px+qy+r$ sera intégrée exactement par la règle point milieu bidimensionnelle. Nous pouvons choisir $f(x,y)=2x+y$ et créer une fonction de test appropriée qui peut automatiquement vérifier nos deux implémentations alternatives de la règle du point milieu bidimensionnelle. La fonction de test devient:</span>
<span style="color: #228B22"># !bc pycod</span>
<span style="color: #228B22"># def test_midpoint_double():</span>
<span style="color: #228B22">#     &quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
<span style="color: #228B22">#     def f(x, y):</span>
<span style="color: #228B22">#         return 2*x + y</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22">#     a = 0;  b = 2;  c = 2;  d = 3</span>
<span style="color: #228B22">#     import sympy</span>
<span style="color: #228B22">#     x, y = sympy.symbols(&#39;x  y&#39;)</span>
<span style="color: #228B22">#     I_expected = sympy.integrate(f(x, y), (x, a, b), (y, c, d))</span>
<span style="color: #228B22">#     # Test three cases: nx &lt; ny, nx = ny, nx &gt; ny</span>
<span style="color: #228B22">#     for nx, ny in (3, 5), (4, 4), (5, 3):</span>
<span style="color: #228B22">#         I_computed1 = midpoint_double1(f, a, b, c, d, nx, ny)</span>
<span style="color: #228B22">#         I_computed2 = midpoint_double2(f, a, b, c, d, nx, ny)</span>
<span style="color: #228B22">#         tol = 1E-14</span>
<span style="color: #228B22">#         #print I_expected, I_computed1, I_computed2</span>
<span style="color: #228B22">#         assert abs(I_computed1 - I_expected) &lt; tol</span>
<span style="color: #228B22">#         assert abs(I_computed2 - I_expected) &lt; tol</span>
<span style="color: #228B22"># !ec</span>
<span style="color: #228B22"># !bnotice Laisser parler les fonctions de test?</span>
<span style="color: #228B22"># Si nous appelons la fonction `test_midpoint_double` ci-dessus et que rien ne se passe, nos implémentations sont correctes. Cependant, il est quelque peu ennuyeux d&#39;avoir une fonction complètement silencieuse lorsqu&#39;elle fonctionne sommes-nous sûrs que tout est correctement calculé? Pendant le développement, il est donc fortement recommandé d&#39;insérer une instruction d&#39;impression afin que nous puissions surveiller les calculs et être convaincu que la fonction de test fait ce que nous voulons. Puisqu&#39;une fonction de test ne doit avoir aucune instruction print(), nous la commentons simplement comme nous l&#39;avons fait dans la fonction listée ci-dessus.</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># !enotice</span>
<span style="color: #228B22"># La méthode du trapèze peut être utilisée comme alternative à la méthode du point milieu. La dérivation d&#39;une formule pour la double intégrale et les implémentations suivent exactement les mêmes idées que nous avons expliquées avec la méthode du point milieu, mais il y a plus de termes à écrire dans les formules.</span>
<span style="color: #228B22"># ===== La règle du point milieu pour une triple intégrale =====</span>
<span style="color: #228B22"># === Théorie ===</span>
<span style="color: #228B22"># Une fois qu&#39;une méthode qui fonctionne pour un problème unidimensionnel est généralisée à deux dimensions, il est généralement assez simple d&#39;étendre la méthode à trois dimensions. Cela sera maintenant démontré pour les intégrales. Nous avons la triple intégrale:</span>
<span style="color: #228B22"># $$\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx$$</span>
<span style="color: #228B22"># et veulent approximer l&#39;intégrale par une règle du point milieu. En suivant les idées de la double intégrale, nous avons divisé cette intégrale en intégrales unidimensionnelles:</span>
<span style="color: #228B22"># !bt</span>
<span style="color: #228B22"># \begin{align*}</span>
<span style="color: #228B22"># p(x,y) &amp;= \int_e^f g(x,y,z) dz\\</span>
<span style="color: #228B22"># q(x) &amp;= \int_c^d p(x,y) dy\\</span>
<span style="color: #228B22"># \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx &amp;= \int_a^b q(x)dx</span>
<span style="color: #228B22"># \end{align*}</span>
<span style="color: #228B22"># !et</span>
<span style="color: #228B22"># Pour chacune de ces intégrales unidimensionnelles, nous appliquons la règle du point milieu:</span>
<span style="color: #228B22"># !bt</span>
<span style="color: #228B22"># \begin{align*}</span>
<span style="color: #228B22"># p(x,y) = \int_e^f g(x,y,z) dz</span>
<span style="color: #228B22"># &amp;\approx \sum_{k=0}^{n_z-1} g(x,y,z_k),</span>
<span style="color: #228B22"># \\</span>
<span style="color: #228B22"># q(x) = \int_c^d p(x,y) dy</span>
<span style="color: #228B22"># &amp;\approx \sum_{j=0}^{n_y-1} p(x,y_j),</span>
<span style="color: #228B22"># \\</span>
<span style="color: #228B22"># \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx = \int_a^b q(x)dx</span>
<span style="color: #228B22"># &amp;\approx \sum_{i=0}^{n_x-1} q(x_i),</span>
<span style="color: #228B22"># \end{align*}</span>
<span style="color: #228B22"># !et</span>
<span style="color: #228B22"># où</span>
<span style="color: #228B22"># $$z_k=e + \frac{1}{2}h_z + kh_z,\quad y_j=c + \frac{1}{2}h_y + jh_y \quad</span>
<span style="color: #228B22"># x_i=a + \frac{1}{2}h_x + ih_x$$</span>
<span style="color: #228B22"># En commençant par la formule pour $\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx$ et en insérant les deux formules précédentes donne</span>
<span style="color: #228B22"># !bt</span>
<span style="color: #228B22"># \begin{align}</span>
<span style="color: #228B22"># &amp; \int_{a}^{b} \int_c^d \int_e^f g(x,y,z)\, dzdydx\approx\nonumber\\</span>
<span style="color: #228B22"># &amp; h_xh_yh_z</span>
<span style="color: #228B22"># \sum_{i=0}^{n_x-1}\sum_{j=0}^{n_y-1}\sum_{k=0}^{n_z-1}</span>
<span style="color: #228B22"># g(a + \frac{1}{2}h_x + ih_x,</span>
<span style="color: #228B22"># c + \frac{1}{2}h_y + jh_y,</span>
<span style="color: #228B22"># e + \frac{1}{2}h_z + kh_z) \label{eq:midpointTriple}</span>
<span style="color: #228B22"># \end{align}</span>
<span style="color: #228B22"># !et</span>
<span style="color: #228B22"># Notez que nous pouvons appliquer les idées sous Dérivation directe à la fin de la section ref{sec:midpointDouble} arrive à (ref{eq:midpointTriple}) directement: diviser le domaine en $n_x\times n_y\times n_z$ cellules de volumes $h_xh_yh_z$; approximativement g par une constante, évaluée au milieu $(x_i,y_j,z_k)$, dans chaque cellule; et additionner les intégrales de cellule $h_xh_yh_zg(x_i,y_j,z_k)$.</span>
<span style="color: #228B22"># === Implémentation ===</span>
<span style="color: #228B22"># Nous suivons les idées pour les implémentations de la règle du point milieu pour une double intégrale. Les fonctions correspondantes sont présentées ci-dessous et se trouvent dans le fichier `midpoint_triple.py`.</span>
<span style="color: #228B22"># !bc pycod</span>
<span style="color: #228B22"># def midpoint_triple1(g, a, b, c, d, e, f, nx, ny, nz):</span>
<span style="color: #228B22">#     hx = (b - a)/float(nx)</span>
<span style="color: #228B22">#     hy = (d - c)/float(ny)</span>
<span style="color: #228B22">#     hz = (f - e)/float(nz)</span>
<span style="color: #228B22">#     I = 0</span>
<span style="color: #228B22">#     for i in range(nx):</span>
<span style="color: #228B22">#         for j in range(ny):</span>
<span style="color: #228B22">#             for k in range(nz):</span>
<span style="color: #228B22">#                 xi = a + hx/2 + i*hx</span>
<span style="color: #228B22">#                 yj = c + hy/2 + j*hy</span>
<span style="color: #228B22">#                 zk = e + hz/2 + k*hz</span>
<span style="color: #228B22">#                 I += hx*hy*hz*g(xi, yj, zk)</span>
<span style="color: #228B22">#     return I</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># def midpoint(f, a, b, n):</span>
<span style="color: #228B22">#     h = float(b-a)/n</span>
<span style="color: #228B22">#     result = 0</span>
<span style="color: #228B22">#     for i in range(n):</span>
<span style="color: #228B22">#         result += f((a + h/2.0) + i*h)</span>
<span style="color: #228B22">#     result *= h</span>
<span style="color: #228B22">#     return result</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># def midpoint_triple2(g, a, b, c, d, e, f, nx, ny, nz):</span>
<span style="color: #228B22">#     def p(x, y):</span>
<span style="color: #228B22">#         return midpoint(lambda z: g(x, y, z), e, f, nz)</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22">#     def q(x):</span>
<span style="color: #228B22">#         return midpoint(lambda y: p(x, y), c, d, ny)</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22">#     return midpoint(q, a, b, nx)</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># def test_midpoint_triple():</span>
<span style="color: #228B22">#     &quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
<span style="color: #228B22">#     def g(x, y, z):</span>
<span style="color: #228B22">#         return 2*x + y - 4*z</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22">#     a = 0;  b = 2;  c = 2;  d = 3;  e = -1;  f = 2</span>
<span style="color: #228B22">#     import sympy</span>
<span style="color: #228B22">#     x, y, z = sympy.symbols(&#39;x y z&#39;)</span>
<span style="color: #228B22">#     I_expected = sympy.integrate(</span>
<span style="color: #228B22">#         g(x, y, z), (x, a, b), (y, c, d), (z, e, f))</span>
<span style="color: #228B22">#     for nx, ny, nz in (3, 5, 2), (4, 4, 4), (5, 3, 6):</span>
<span style="color: #228B22">#         I_computed1 = midpoint_triple1(</span>
<span style="color: #228B22">#             g, a, b, c, d, e, f, nx, ny, nz)</span>
<span style="color: #228B22">#         I_computed2 = midpoint_triple2(</span>
<span style="color: #228B22">#             g, a, b, c, d, e, f, nx, ny, nz)</span>
<span style="color: #228B22">#         tol = 1E-14</span>
<span style="color: #228B22">#         print(I_expected, I_computed1, I_computed2)</span>
<span style="color: #228B22">#         assert abs(I_computed1 - I_expected) &lt; tol</span>
<span style="color: #228B22">#         assert abs(I_computed2 - I_expected) &lt; tol</span>
<span style="color: #228B22">#</span>
<span style="color: #228B22"># if __name__ == &#39;__main__&#39;:</span>
<span style="color: #228B22">#     test_midpoint_triple()</span>
<span style="color: #228B22"># !ec</span>

<span style="color: #000080; font-weight: bold">======= Intégration Monte Carlo =======</span>
Les méthodes de Monte Carlo sont des techniques de calcul probabilistes. Au cœur, un algorithme de Monte Carlo représente de façon aléatoire certaines valeurs de l&#39;espace de valeurs d&#39;un paramètre considéré. La combinaison de plusieurs paramètres permet de tirer des conclusions stochastiques des relations. L&#39;intégration des fonctions mathématiques de la forme:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation*}</span>
A = \int_a^b f(x) \cdot dx
<span style="color: #658b00">\end{equation*}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>

Pour effectuer une intégration, nous voulons savoir comment les valeurs sélectionnées au hasard sont réparties: lesquelles des valeurs sont égales ou inférieures à la valeur de la fonction et lesquelles sont supérieures. Il s&#39;agit d&#39;une décision binaire qui divise les valeurs aléatoires en deux groupes. Du rapport de la taille des groupes, nous pouvons tirer nos conclusions.

Nous utilisons la fonction (intégrande) comme critère de décision uniquement. L&#39;algorithme ne nous fournit rien d&#39;autre que des comptes/fréquences. La fermeture probabiliste est alors:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{equation*}</span>
\frac{\textrm{cas favorables}} {\textrm{cas possibles}} = \frac {n}{N} = \frac{A_{sous\;la\;fonction}}{A_{aire \;totale}}
<span style="color: #658b00">\end{equation*}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
La zone $A_{sous\;la\;fonction}$ est la zone inconnue qui nous intéresse. Pour $A_{aire \;totale}$, nous choisissons arbitrairement une région simple, cette zone que nous pouvons calculer sans difficultés.

<span style="color: #000080; font-weight: bold">===== Exemple: détermination de $\pi$ =====</span>
À titre d&#39;exemple, nous choisissons un cercle dont la fonction mathématique est donnée par la première:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align*}</span>
x^2 + y^2 &amp;= R^2 \\
y = f(x) &amp;= \sqrt{R^2 - x^2}
<span style="color: #658b00">\end{align*}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Pour l&#39;estimation de $\pi$, l&#39;aire du cercle est comparée à l&#39;aire du carré $2R \times 2R$, ce rapport est $\pi / 4$:
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align*}</span>
A_{cercle} &amp;= R^2 \cdot \pi \\
A_{carré} &amp;= {(2R)}^2 = 4R^2
<span style="color: #658b00">\end{align*}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
Nous générons au hasard $(x_rand, y_rand)$-points. Pour chaque point, nous devons décider s&#39;il se trouve à l&#39;intérieur ou à l&#39;extérieur du cercle. Pour cela, nous utilisons la différence $y_{rand} - f(x_{rand})$, où $f(x) = \sqrt{R^2 - x^2}$ est la fonction d&#39;un cercle dans le premier quadrant. Nous pouvons compter le nombre de points à l&#39;intérieur du cercle. Nous pouvons compter le nombre de points à l&#39;intérieur du cercle. Le rapport $n / N$ est supposé être égal au rapport $A_{cercle}/A_{carré}$
<span style="color: #8B008B; font-weight: bold">!bt</span>
<span style="color: #658b00">\begin{align*}</span>
\frac {\textrm{n = (x,y)-points dans le cercle}}  {\textrm{N = (x,y)-points dans le carré}} &amp;= \frac{A_{cercle}}{A_{carré}}
 = \frac {R^2 \cdot \pi}{4R^2 } = \frac {\pi}{4} \\
\pi &amp;= 4\frac{n}{N}
<span style="color: #658b00">\end{align*}</span>
<span style="color: #8B008B; font-weight: bold">!et</span>
<span style="color: #000080; font-weight: bold">===== implémentation =====</span>
Nous avons vu l&#39;intégration de Monte Carlo lorsque nous avons calculé $\pi / 4$ en calculant l&#39;aire du quart de cercle unitaire.

Voici le code:

<span style="color: #800080; font-weight: bold">@@@CODE scripts/MC_integral.py</span>
<span style="color: #8B008B; font-weight: bold">!bc</span>
PI numpy       :  3.141592653589793
PI monte carlo :  3.1436
différence     :  0.002007346410207056
<span style="color: #8B008B; font-weight: bold">!ec</span>
<span style="color: #658b00">FIGURE: [imgs/MC_integral, width=400 frac=0.7]</span>

Nous pouvons généraliser cette approche aux courbes autres que $y = \sqrt{1-x^2}$. L&#39;idée est la suivante: pour une courbe arbitraire, trouvez le rectangle qui la contient, générez un point aléatoire dans ce rectangle et déterminez combien de points aléatoires se trouvent sous la courbe.
</pre></div>
